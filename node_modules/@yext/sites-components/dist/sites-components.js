var Un = Object.defineProperty;
var Fn = (n, e, t) => e in n ? Un(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var re = (n, e, t) => (Fn(n, typeof e != "symbol" ? e + "" : e, t), t);
import ke, { createContext as ot, useContext as we, useRef as at, useState as ie, useEffect as ae, Fragment as $n, useMemo as Gn } from "react";
import { createPortal as Zn } from "react-dom";
var Vn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Vt(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var Qe = { exports: {} }, Te = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var It;
function Wn() {
  if (It)
    return Te;
  It = 1;
  var n = ke, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, s = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function c(u, p, a) {
    var d, f = {}, _ = null, y = null;
    a !== void 0 && (_ = "" + a), p.key !== void 0 && (_ = "" + p.key), p.ref !== void 0 && (y = p.ref);
    for (d in p)
      r.call(p, d) && !i.hasOwnProperty(d) && (f[d] = p[d]);
    if (u && u.defaultProps)
      for (d in p = u.defaultProps, p)
        f[d] === void 0 && (f[d] = p[d]);
    return { $$typeof: e, type: u, key: _, ref: y, props: f, _owner: s.current };
  }
  return Te.Fragment = t, Te.jsx = c, Te.jsxs = c, Te;
}
var Re = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Mt;
function zn() {
  return Mt || (Mt = 1, process.env.NODE_ENV !== "production" && function() {
    var n = ke, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), c = Symbol.for("react.provider"), u = Symbol.for("react.context"), p = Symbol.for("react.forward_ref"), a = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), _ = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), v = Symbol.iterator, E = "@@iterator";
    function A(o) {
      if (o === null || typeof o != "object")
        return null;
      var h = v && o[v] || o[E];
      return typeof h == "function" ? h : null;
    }
    var U = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function T(o) {
      {
        for (var h = arguments.length, m = new Array(h > 1 ? h - 1 : 0), w = 1; w < h; w++)
          m[w - 1] = arguments[w];
        q("error", o, m);
      }
    }
    function q(o, h, m) {
      {
        var w = U.ReactDebugCurrentFrame, I = w.getStackAddendum();
        I !== "" && (h += "%s", m = m.concat([I]));
        var k = m.map(function(P) {
          return String(P);
        });
        k.unshift("Warning: " + h), Function.prototype.apply.call(console[o], console, k);
      }
    }
    var D = !1, $ = !1, K = !1, ne = !1, G = !1, x;
    x = Symbol.for("react.module.reference");
    function te(o) {
      return !!(typeof o == "string" || typeof o == "function" || o === r || o === i || G || o === s || o === a || o === d || ne || o === y || D || $ || K || typeof o == "object" && o !== null && (o.$$typeof === _ || o.$$typeof === f || o.$$typeof === c || o.$$typeof === u || o.$$typeof === p || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      o.$$typeof === x || o.getModuleId !== void 0));
    }
    function X(o, h, m) {
      var w = o.displayName;
      if (w)
        return w;
      var I = h.displayName || h.name || "";
      return I !== "" ? m + "(" + I + ")" : m;
    }
    function Se(o) {
      return o.displayName || "Context";
    }
    function Y(o) {
      if (o == null)
        return null;
      if (typeof o.tag == "number" && T("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof o == "function")
        return o.displayName || o.name || null;
      if (typeof o == "string")
        return o;
      switch (o) {
        case r:
          return "Fragment";
        case t:
          return "Portal";
        case i:
          return "Profiler";
        case s:
          return "StrictMode";
        case a:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof o == "object")
        switch (o.$$typeof) {
          case u:
            var h = o;
            return Se(h) + ".Consumer";
          case c:
            var m = o;
            return Se(m._context) + ".Provider";
          case p:
            return X(o, o.render, "ForwardRef");
          case f:
            var w = o.displayName || null;
            return w !== null ? w : Y(o.type) || "Memo";
          case _: {
            var I = o, k = I._payload, P = I._init;
            try {
              return Y(P(k));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var l = Object.assign, g = 0, b, F, H, M, ue, ce, me;
    function ht() {
    }
    ht.__reactDisabledLog = !0;
    function gn() {
      {
        if (g === 0) {
          b = console.log, F = console.info, H = console.warn, M = console.error, ue = console.group, ce = console.groupCollapsed, me = console.groupEnd;
          var o = {
            configurable: !0,
            enumerable: !0,
            value: ht,
            writable: !0
          };
          Object.defineProperties(console, {
            info: o,
            log: o,
            warn: o,
            error: o,
            group: o,
            groupCollapsed: o,
            groupEnd: o
          });
        }
        g++;
      }
    }
    function mn() {
      {
        if (g--, g === 0) {
          var o = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: l({}, o, {
              value: b
            }),
            info: l({}, o, {
              value: F
            }),
            warn: l({}, o, {
              value: H
            }),
            error: l({}, o, {
              value: M
            }),
            group: l({}, o, {
              value: ue
            }),
            groupCollapsed: l({}, o, {
              value: ce
            }),
            groupEnd: l({}, o, {
              value: me
            })
          });
        }
        g < 0 && T("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Ue = U.ReactCurrentDispatcher, Fe;
    function xe(o, h, m) {
      {
        if (Fe === void 0)
          try {
            throw Error();
          } catch (I) {
            var w = I.stack.trim().match(/\n( *(at )?)/);
            Fe = w && w[1] || "";
          }
        return `
` + Fe + o;
      }
    }
    var $e = !1, Oe;
    {
      var _n = typeof WeakMap == "function" ? WeakMap : Map;
      Oe = new _n();
    }
    function pt(o, h) {
      if (!o || $e)
        return "";
      {
        var m = Oe.get(o);
        if (m !== void 0)
          return m;
      }
      var w;
      $e = !0;
      var I = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var k;
      k = Ue.current, Ue.current = null, gn();
      try {
        if (h) {
          var P = function() {
            throw Error();
          };
          if (Object.defineProperty(P.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(P, []);
            } catch (se) {
              w = se;
            }
            Reflect.construct(o, [], P);
          } else {
            try {
              P.call();
            } catch (se) {
              w = se;
            }
            o.call(P.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (se) {
            w = se;
          }
          o();
        }
      } catch (se) {
        if (se && w && typeof se.stack == "string") {
          for (var C = se.stack.split(`
`), Z = w.stack.split(`
`), B = C.length - 1, j = Z.length - 1; B >= 1 && j >= 0 && C[B] !== Z[j]; )
            j--;
          for (; B >= 1 && j >= 0; B--, j--)
            if (C[B] !== Z[j]) {
              if (B !== 1 || j !== 1)
                do
                  if (B--, j--, j < 0 || C[B] !== Z[j]) {
                    var J = `
` + C[B].replace(" at new ", " at ");
                    return o.displayName && J.includes("<anonymous>") && (J = J.replace("<anonymous>", o.displayName)), typeof o == "function" && Oe.set(o, J), J;
                  }
                while (B >= 1 && j >= 0);
              break;
            }
        }
      } finally {
        $e = !1, Ue.current = k, mn(), Error.prepareStackTrace = I;
      }
      var ve = o ? o.displayName || o.name : "", Rt = ve ? xe(ve) : "";
      return typeof o == "function" && Oe.set(o, Rt), Rt;
    }
    function vn(o, h, m) {
      return pt(o, !1);
    }
    function wn(o) {
      var h = o.prototype;
      return !!(h && h.isReactComponent);
    }
    function Le(o, h, m) {
      if (o == null)
        return "";
      if (typeof o == "function")
        return pt(o, wn(o));
      if (typeof o == "string")
        return xe(o);
      switch (o) {
        case a:
          return xe("Suspense");
        case d:
          return xe("SuspenseList");
      }
      if (typeof o == "object")
        switch (o.$$typeof) {
          case p:
            return vn(o.render);
          case f:
            return Le(o.type, h, m);
          case _: {
            var w = o, I = w._payload, k = w._init;
            try {
              return Le(k(I), h, m);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, ft = {}, gt = U.ReactDebugCurrentFrame;
    function De(o) {
      if (o) {
        var h = o._owner, m = Le(o.type, o._source, h ? h.type : null);
        gt.setExtraStackFrame(m);
      } else
        gt.setExtraStackFrame(null);
    }
    function yn(o, h, m, w, I) {
      {
        var k = Function.call.bind(Ae);
        for (var P in o)
          if (k(o, P)) {
            var C = void 0;
            try {
              if (typeof o[P] != "function") {
                var Z = Error((w || "React class") + ": " + m + " type `" + P + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[P] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Z.name = "Invariant Violation", Z;
              }
              C = o[P](h, P, w, m, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (B) {
              C = B;
            }
            C && !(C instanceof Error) && (De(I), T("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", w || "React class", m, P, typeof C), De(null)), C instanceof Error && !(C.message in ft) && (ft[C.message] = !0, De(I), T("Failed %s type: %s", m, C.message), De(null));
          }
      }
    }
    var bn = Array.isArray;
    function Ge(o) {
      return bn(o);
    }
    function Cn(o) {
      {
        var h = typeof Symbol == "function" && Symbol.toStringTag, m = h && o[Symbol.toStringTag] || o.constructor.name || "Object";
        return m;
      }
    }
    function En(o) {
      try {
        return mt(o), !1;
      } catch {
        return !0;
      }
    }
    function mt(o) {
      return "" + o;
    }
    function _t(o) {
      if (En(o))
        return T("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Cn(o)), mt(o);
    }
    var Pe = U.ReactCurrentOwner, Pn = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, vt, wt, Ze;
    Ze = {};
    function Tn(o) {
      if (Ae.call(o, "ref")) {
        var h = Object.getOwnPropertyDescriptor(o, "ref").get;
        if (h && h.isReactWarning)
          return !1;
      }
      return o.ref !== void 0;
    }
    function Rn(o) {
      if (Ae.call(o, "key")) {
        var h = Object.getOwnPropertyDescriptor(o, "key").get;
        if (h && h.isReactWarning)
          return !1;
      }
      return o.key !== void 0;
    }
    function In(o, h) {
      if (typeof o.ref == "string" && Pe.current && h && Pe.current.stateNode !== h) {
        var m = Y(Pe.current.type);
        Ze[m] || (T('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Y(Pe.current.type), o.ref), Ze[m] = !0);
      }
    }
    function Mn(o, h) {
      {
        var m = function() {
          vt || (vt = !0, T("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", h));
        };
        m.isReactWarning = !0, Object.defineProperty(o, "key", {
          get: m,
          configurable: !0
        });
      }
    }
    function kn(o, h) {
      {
        var m = function() {
          wt || (wt = !0, T("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", h));
        };
        m.isReactWarning = !0, Object.defineProperty(o, "ref", {
          get: m,
          configurable: !0
        });
      }
    }
    var Sn = function(o, h, m, w, I, k, P) {
      var C = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: o,
        key: h,
        ref: m,
        props: P,
        // Record the component responsible for creating this element.
        _owner: k
      };
      return C._store = {}, Object.defineProperty(C._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(C, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: w
      }), Object.defineProperty(C, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: I
      }), Object.freeze && (Object.freeze(C.props), Object.freeze(C)), C;
    };
    function xn(o, h, m, w, I) {
      {
        var k, P = {}, C = null, Z = null;
        m !== void 0 && (_t(m), C = "" + m), Rn(h) && (_t(h.key), C = "" + h.key), Tn(h) && (Z = h.ref, In(h, I));
        for (k in h)
          Ae.call(h, k) && !Pn.hasOwnProperty(k) && (P[k] = h[k]);
        if (o && o.defaultProps) {
          var B = o.defaultProps;
          for (k in B)
            P[k] === void 0 && (P[k] = B[k]);
        }
        if (C || Z) {
          var j = typeof o == "function" ? o.displayName || o.name || "Unknown" : o;
          C && Mn(P, j), Z && kn(P, j);
        }
        return Sn(o, C, Z, I, w, Pe.current, P);
      }
    }
    var Ve = U.ReactCurrentOwner, yt = U.ReactDebugCurrentFrame;
    function _e(o) {
      if (o) {
        var h = o._owner, m = Le(o.type, o._source, h ? h.type : null);
        yt.setExtraStackFrame(m);
      } else
        yt.setExtraStackFrame(null);
    }
    var We;
    We = !1;
    function ze(o) {
      return typeof o == "object" && o !== null && o.$$typeof === e;
    }
    function bt() {
      {
        if (Ve.current) {
          var o = Y(Ve.current.type);
          if (o)
            return `

Check the render method of \`` + o + "`.";
        }
        return "";
      }
    }
    function On(o) {
      {
        if (o !== void 0) {
          var h = o.fileName.replace(/^.*[\\\/]/, ""), m = o.lineNumber;
          return `

Check your code at ` + h + ":" + m + ".";
        }
        return "";
      }
    }
    var Ct = {};
    function Ln(o) {
      {
        var h = bt();
        if (!h) {
          var m = typeof o == "string" ? o : o.displayName || o.name;
          m && (h = `

Check the top-level render call using <` + m + ">.");
        }
        return h;
      }
    }
    function Et(o, h) {
      {
        if (!o._store || o._store.validated || o.key != null)
          return;
        o._store.validated = !0;
        var m = Ln(h);
        if (Ct[m])
          return;
        Ct[m] = !0;
        var w = "";
        o && o._owner && o._owner !== Ve.current && (w = " It was passed a child from " + Y(o._owner.type) + "."), _e(o), T('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', m, w), _e(null);
      }
    }
    function Pt(o, h) {
      {
        if (typeof o != "object")
          return;
        if (Ge(o))
          for (var m = 0; m < o.length; m++) {
            var w = o[m];
            ze(w) && Et(w, h);
          }
        else if (ze(o))
          o._store && (o._store.validated = !0);
        else if (o) {
          var I = A(o);
          if (typeof I == "function" && I !== o.entries)
            for (var k = I.call(o), P; !(P = k.next()).done; )
              ze(P.value) && Et(P.value, h);
        }
      }
    }
    function An(o) {
      {
        var h = o.type;
        if (h == null || typeof h == "string")
          return;
        var m;
        if (typeof h == "function")
          m = h.propTypes;
        else if (typeof h == "object" && (h.$$typeof === p || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        h.$$typeof === f))
          m = h.propTypes;
        else
          return;
        if (m) {
          var w = Y(h);
          yn(m, o.props, "prop", w, o);
        } else if (h.PropTypes !== void 0 && !We) {
          We = !0;
          var I = Y(h);
          T("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", I || "Unknown");
        }
        typeof h.getDefaultProps == "function" && !h.getDefaultProps.isReactClassApproved && T("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Dn(o) {
      {
        for (var h = Object.keys(o.props), m = 0; m < h.length; m++) {
          var w = h[m];
          if (w !== "children" && w !== "key") {
            _e(o), T("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", w), _e(null);
            break;
          }
        }
        o.ref !== null && (_e(o), T("Invalid attribute `ref` supplied to `React.Fragment`."), _e(null));
      }
    }
    function Tt(o, h, m, w, I, k) {
      {
        var P = te(o);
        if (!P) {
          var C = "";
          (o === void 0 || typeof o == "object" && o !== null && Object.keys(o).length === 0) && (C += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Z = On(I);
          Z ? C += Z : C += bt();
          var B;
          o === null ? B = "null" : Ge(o) ? B = "array" : o !== void 0 && o.$$typeof === e ? (B = "<" + (Y(o.type) || "Unknown") + " />", C = " Did you accidentally export a JSX literal instead of a component?") : B = typeof o, T("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", B, C);
        }
        var j = xn(o, h, m, I, k);
        if (j == null)
          return j;
        if (P) {
          var J = h.children;
          if (J !== void 0)
            if (w)
              if (Ge(J)) {
                for (var ve = 0; ve < J.length; ve++)
                  Pt(J[ve], o);
                Object.freeze && Object.freeze(J);
              } else
                T("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Pt(J, o);
        }
        return o === r ? Dn(j) : An(j), j;
      }
    }
    function Bn(o, h, m) {
      return Tt(o, h, m, !0);
    }
    function Nn(o, h, m) {
      return Tt(o, h, m, !1);
    }
    var Hn = Nn, jn = Bn;
    Re.Fragment = r, Re.jsx = Hn, Re.jsxs = jn;
  }()), Re;
}
process.env.NODE_ENV === "production" ? Qe.exports = Wn() : Qe.exports = zn();
var R = Qe.exports;
function Yn(n) {
  switch (n) {
    case "AD":
    case "AM":
    case "AT":
    case "AX":
    case "AZ":
    case "BA":
    case "BY":
    case "CY":
    case "CZ":
    case "DK":
    case "DZ":
    case "EC":
    case "EH":
    case "ET":
    case "FI":
    case "FR":
    case "GE":
    case "GF":
    case "GI":
    case "GP":
    case "GW":
    case "HT":
    case "KE":
    case "KV":
    case "KW":
    case "LA":
    case "LU":
    case "MC":
    case "MD":
    case "ME":
    case "MG":
    case "MK":
    case "MQ":
    case "MZ":
    case "NC":
    case "NL":
    case "NO":
    case "PL":
    case "PT":
    case "PY":
    case "RE":
    case "RS":
    case "SA":
    case "SE":
    case "SJ":
    case "SM":
    case "SN":
    case "TC":
    case "TJ":
    case "TM":
    case "TN":
    case "TZ":
    case "UY":
    case "VG":
    case "ZM":
      return [["line1"], ["line2"], ["postalCode", "city"], ["countryCode"]];
    case "AF":
    case "IR":
      return [
        ["line1"],
        ["line2"],
        ["city"],
        ["region"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "AG":
    case "AO":
    case "AW":
    case "BJ":
    case "BO":
    case "BS":
    case "BZ":
    case "CI":
    case "CW":
    case "DJ":
    case "FJ":
    case "GA":
    case "GH":
    case "GM":
    case "GY":
    case "JM":
    case "KI":
    case "LY":
    case "MW":
    case "NA":
    case "NR":
    case "PS":
    case "QA":
    case "RW":
    case "SC":
    case "SR":
    case "SX":
    case "TG":
    case "TT":
    case "UG":
    case "VU":
      return [["line1"], ["line2"], ["city"], ["countryCode"]];
    case "AL":
    case "EE":
    case "IS":
      return [["line1"], ["line2"], ["postalCode", "city"]];
    case "AR":
      return [
        ["line1"],
        ["line2"],
        ["postalCode", "city", ",", "region"],
        ["countryCode"]
      ];
    case "AS":
    case "BB":
    case "BD":
    case "BM":
    case "BN":
    case "BT":
    case "CR":
    case "DO":
    case "FK":
    case "FM":
    case "GR":
    case "GU":
    case "JO":
    case "KZ":
    case "LB":
    case "LK":
    case "LS":
    case "MA":
    case "MH":
    case "MM":
    case "MR":
    case "MT":
    case "MV":
    case "NG":
    case "PG":
    case "PK":
    case "PR":
    case "RO":
    case "SG":
    case "VC":
    case "WS":
      return [["line1"], ["line2"], ["city", "postalCode"], ["countryCode"]];
    case "AU":
    case "CA":
    case "SZ":
    case "US":
    case "VI":
      return [
        ["line1"],
        ["line2"],
        ["city", ",", "region", "postalCode"],
        ["countryCode"]
      ];
    case "BE":
    case "PE":
      return [
        ["line1"],
        ["line2"],
        ["postalCode", "sublocality", "city"],
        ["countryCode"]
      ];
    case "BF":
    case "BI":
    case "BQ":
    case "BW":
    case "CF":
    case "CG":
    case "CM":
    case "DM":
    case "ER":
    case "GQ":
    case "KM":
    case "ML":
    case "SY":
    case "TD":
    case "ZW":
      return [["line1"], ["line2"], ["city"], ["region"], ["countryCode"]];
    case "BG":
      return [["line1"], ["postalCode", "region"], ["countryCode"]];
    case "BH":
      return [["line1"], ["line2"], ["sublocality", "city"], ["countryCode"]];
    case "BR":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city", "region"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "CH":
    case "DE":
    case "GT":
    case "IT":
    case "LI":
    case "MY":
    case "NI":
    case "OM":
    case "SK":
    case "VA":
      return [
        ["line1"],
        ["line2"],
        ["postalCode", "city", "region"],
        ["countryCode"]
      ];
    case "CL":
    case "PF":
      return [
        ["line1"],
        ["line2"],
        ["city", "postalCode", "region"],
        ["countryCode"]
      ];
    case "CN":
      return [
        ["region", "city", "sublocality"],
        ["line1"],
        ["line2"],
        ["countryCode"]
      ];
    case "CO":
    case "ID":
    case "IQ":
    case "KH":
    case "MP":
    case "NP":
    case "PW":
    case "UA":
      return [
        ["line1"],
        ["line2"],
        ["city", "region", "postalCode"],
        ["countryCode"]
      ];
    case "EG":
      return [
        ["line1"],
        ["line2"],
        ["sublocality", "city", "region", "postalCode"],
        ["countryCode"]
      ];
    case "ES":
    case "IL":
      return [
        ["line1"],
        ["line2"],
        ["city", "postalCode"],
        ["region"],
        ["countryCode"]
      ];
    case "GB":
    case "MN":
    case "ZA":
      return [
        ["line1"],
        ["line2"],
        ["sublocality", "city", "postalCode"],
        ["countryCode"]
      ];
    case "GG":
    case "IM":
    case "JE":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "GN":
      return [["line1", "line2", "city"], ["countryCode"]];
    case "HK":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city"],
        ["region"],
        ["countryCode"]
      ];
    case "HR":
      return [["line1"], ["postalCode", "city", "region"], ["countryCode"]];
    case "HU":
    case "SI":
      return [["postalCode", "city"], ["line1"], ["line2"], ["countryCode"]];
    case "IE":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city", "region", "postalCode"],
        ["countryCode"]
      ];
    case "IN":
    case "VE":
      return [
        ["line1"],
        ["line2"],
        ["city", "postalCode"],
        ["region"],
        ["countryCode"]
      ];
    case "JP":
      return [
        ["line2"],
        ["line1", "sublocality"],
        ["city", "region"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "KR":
      return [
        ["countryCode"],
        ["region", "city", "sublocality", "line1"],
        ["line2"],
        ["postalCode"]
      ];
    case "KY":
      return [["line1"], ["line2"], ["postalCode"], ["countryCode"]];
    case "LT":
      return [
        ["line1"],
        ["postalCode", "city", "sublocality", "region"],
        ["countryCode"]
      ];
    case "LV":
      return [["line1"], ["city", ",", "postalCode"], ["countryCode"]];
    case "MO":
      return [["line1"], ["line2"], ["sublocality"], ["city"], ["countryCode"]];
    case "MU":
      return [
        ["line1"],
        ["line2"],
        ["city"],
        ["region", "postalCode"],
        ["countryCode"]
      ];
    case "MX":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["postalCode", "city", ",", "region"],
        ["countryCode"]
      ];
    case "NE":
    case "SD":
      return [
        ["line1"],
        ["line2"],
        ["postalCode"],
        ["city"],
        ["region"],
        ["countryCode"]
      ];
    case "NZ":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "PH":
    case "TW":
    case "VN":
      return [
        ["line1"],
        ["line2"],
        ["sublocality", "city"],
        ["region", "postalCode"],
        ["countryCode"]
      ];
    case "RU":
      return [["line1"], ["line2"], ["city"], ["postalCode"], ["countryCode"]];
    case "SB":
    case "SL":
    case "ST":
    case "TL":
    case "TO":
    case "TV":
      return [["line1"], ["line2"], ["city", ",", "region"], ["countryCode"]];
    case "TH":
    case "TR":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["postalCode", "city"],
        ["countryCode"]
      ];
    case "UZ":
      return [["line1"], ["line2"], ["region", "postalCode"], ["countryCode"]];
  }
  return [
    ["line1", "line2"],
    ["city", "region", "postalCode"],
    ["countryCode"]
  ];
}
const qn = {
  GOOGLEMYBUSINESS: "GOOGLEMYBUSINESS"
}, kt = {
  GOOGLE: "google",
  APPLE: "apple",
  BING: "bing"
}, Kn = (n, e) => {
  const r = {
    region: "localizedRegionName",
    countryCode: "localizedCountryName"
  }[n];
  return r && e[r];
}, Ri = (n, e = [], t, r = {
  route: !1
}) => {
  const s = "Failed to construct query for maps service.";
  let i = n && St([
    n.line1,
    n.line2,
    n.city,
    n.region,
    n.postalCode,
    n.countryCode
  ]);
  switch (r.provider) {
    case kt.APPLE: {
      if (!i) {
        console.warn(
          `${s} Check that you've provided a valid Yext Address.`
        );
        break;
      }
      return Xn(i, r.route);
    }
    case kt.BING: {
      if (i = n && St([
        n.line1,
        n.city,
        n.region,
        n.postalCode
      ]), !i) {
        console.warn(
          `${s} Check that you've provided a valid Yext Address.`
        );
        break;
      }
      return Jn(i, r.route);
    }
    default: {
      const c = e.find(
        (u) => u && u.publisher && u.publisher.toUpperCase() === qn.GOOGLEMYBUSINESS
      );
      if (c && c.listingUrl)
        return c.listingUrl;
      if (t)
        return Qn(t, i, r.route);
      if (!i) {
        console.warn(
          `${s} Check that you've provided a valid Yext Address, Yext ListingType, or Google Place ID.`
        );
        break;
      }
      return er(i, r.route);
    }
  }
}, Xn = (n, e) => e ? `https://maps.apple.com/?daddr=${n}` : `https://maps.apple.com/?address=${n}`, Jn = (n, e) => e ? `https://bing.com/maps/default.aspx?rtp=adr.${n}` : `https://bing.com/maps/default.aspx?where1=${n}`, Qn = (n, e, t) => {
  const r = e ? `&query=${e}` : "";
  return t ? `https://maps.google.com/maps/dir/?api=1${r}&destination_place_id=${n}&destination=direct` : `https://maps.google.com/maps/dir/?api=1&destination_place_id=${n}&destination=direct`;
}, er = (n, e) => e ? `https://maps.google.com/maps/dir/?api=1&destination=${n}` : `https://maps.google.com/maps/search/?api=1&query=${n}`, St = (n = []) => {
  if (!n.length)
    return "";
  const e = n.filter(Boolean).join(", ");
  return encodeURI(e);
}, tr = ({
  address: n,
  lines: e,
  separator: t,
  ...r
}) => {
  const s = (e || Yn(n.countryCode)).map(
    (i) => /* @__PURE__ */ R.jsx(
      nr,
      {
        address: n,
        line: i,
        separator: t
      },
      i.toString()
    )
  );
  return /* @__PURE__ */ R.jsx("div", { ...r, children: s });
};
tr.defaultProps = {
  separator: ","
};
const nr = ({
  address: n,
  line: e,
  separator: t
}) => {
  const r = [];
  for (const s of e) {
    if (s === ",") {
      r.push(/* @__PURE__ */ R.jsx("span", { children: t }, s));
      continue;
    }
    const i = n[s];
    if (!i)
      continue;
    const c = Kn(s, n);
    if (c) {
      r.push(
        /* @__PURE__ */ R.jsxs("abbr", { title: c, children: [
          " ",
          i
        ] }, s)
      );
      continue;
    }
    r.push(/* @__PURE__ */ R.jsxs("span", { children: [
      " ",
      i
    ] }, s));
  }
  return /* @__PURE__ */ R.jsx("div", { children: r });
};
var be = {};
Object.defineProperty(be, "__esModule", {
  value: !0
});
var rr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(n) {
  return typeof n;
} : function(n) {
  return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n;
}, ir = typeof window < "u" && typeof window.document < "u", sr = typeof process < "u" && process.versions != null && process.versions.node != null, or = (typeof self > "u" ? "undefined" : rr(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope", ar = typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom")), cr = typeof Deno < "u" && typeof Deno.version < "u" && typeof Deno.version.deno < "u", xt = be.isBrowser = ir;
be.isWebWorker = or;
var lr = be.isNode = sr;
be.isJsDom = ar;
var ur = be.isDeno = cr;
class dr {
  constructor() {
    re(this, "name");
    /**
     * Whether or not the current runtime is being executed server-side or client-side. If the runtime
     * is node or deno then isServerSide will be true. When the runtime is browser isServerSide is
     * false.
     */
    re(this, "isServerSide");
    re(this, "version");
    var e;
    ur ? (this.name = "deno", this.version = "", xt && (this.version = ((e = window.Deno) == null ? void 0 : e.version.deno) || ""), this.isServerSide = !0) : lr ? (this.name = "node", this.version = process.versions.node, this.isServerSide = !0) : xt ? (this.name = "browser", this.version = navigator.userAgent, this.isServerSide = !1) : (this.name = "unknown", this.version = "", this.isServerSide = !1);
  }
  getNodeMajorVersion() {
    if (this.name != "node")
      throw new Error("Not running in Node.");
    return +this.version.split(".")[0];
  }
}
const ye = () => new dr(), Ot = (n) => {
  var t;
  return ye().name === "browser" && (n == null ? void 0 : n.includes((t = window == null ? void 0 : window.location) == null ? void 0 : t.hostname));
};
var et = { exports: {} };
(function(n, e) {
  var t = typeof self < "u" ? self : Vn, r = function() {
    function i() {
      this.fetch = !1, this.DOMException = t.DOMException;
    }
    return i.prototype = t, new i();
  }();
  (function(i) {
    (function(c) {
      var u = {
        searchParams: "URLSearchParams" in i,
        iterable: "Symbol" in i && "iterator" in Symbol,
        blob: "FileReader" in i && "Blob" in i && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in i,
        arrayBuffer: "ArrayBuffer" in i
      };
      function p(l) {
        return l && DataView.prototype.isPrototypeOf(l);
      }
      if (u.arrayBuffer)
        var a = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], d = ArrayBuffer.isView || function(l) {
          return l && a.indexOf(Object.prototype.toString.call(l)) > -1;
        };
      function f(l) {
        if (typeof l != "string" && (l = String(l)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(l))
          throw new TypeError("Invalid character in header field name");
        return l.toLowerCase();
      }
      function _(l) {
        return typeof l != "string" && (l = String(l)), l;
      }
      function y(l) {
        var g = {
          next: function() {
            var b = l.shift();
            return { done: b === void 0, value: b };
          }
        };
        return u.iterable && (g[Symbol.iterator] = function() {
          return g;
        }), g;
      }
      function v(l) {
        this.map = {}, l instanceof v ? l.forEach(function(g, b) {
          this.append(b, g);
        }, this) : Array.isArray(l) ? l.forEach(function(g) {
          this.append(g[0], g[1]);
        }, this) : l && Object.getOwnPropertyNames(l).forEach(function(g) {
          this.append(g, l[g]);
        }, this);
      }
      v.prototype.append = function(l, g) {
        l = f(l), g = _(g);
        var b = this.map[l];
        this.map[l] = b ? b + ", " + g : g;
      }, v.prototype.delete = function(l) {
        delete this.map[f(l)];
      }, v.prototype.get = function(l) {
        return l = f(l), this.has(l) ? this.map[l] : null;
      }, v.prototype.has = function(l) {
        return this.map.hasOwnProperty(f(l));
      }, v.prototype.set = function(l, g) {
        this.map[f(l)] = _(g);
      }, v.prototype.forEach = function(l, g) {
        for (var b in this.map)
          this.map.hasOwnProperty(b) && l.call(g, this.map[b], b, this);
      }, v.prototype.keys = function() {
        var l = [];
        return this.forEach(function(g, b) {
          l.push(b);
        }), y(l);
      }, v.prototype.values = function() {
        var l = [];
        return this.forEach(function(g) {
          l.push(g);
        }), y(l);
      }, v.prototype.entries = function() {
        var l = [];
        return this.forEach(function(g, b) {
          l.push([b, g]);
        }), y(l);
      }, u.iterable && (v.prototype[Symbol.iterator] = v.prototype.entries);
      function E(l) {
        if (l.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        l.bodyUsed = !0;
      }
      function A(l) {
        return new Promise(function(g, b) {
          l.onload = function() {
            g(l.result);
          }, l.onerror = function() {
            b(l.error);
          };
        });
      }
      function U(l) {
        var g = new FileReader(), b = A(g);
        return g.readAsArrayBuffer(l), b;
      }
      function T(l) {
        var g = new FileReader(), b = A(g);
        return g.readAsText(l), b;
      }
      function q(l) {
        for (var g = new Uint8Array(l), b = new Array(g.length), F = 0; F < g.length; F++)
          b[F] = String.fromCharCode(g[F]);
        return b.join("");
      }
      function D(l) {
        if (l.slice)
          return l.slice(0);
        var g = new Uint8Array(l.byteLength);
        return g.set(new Uint8Array(l)), g.buffer;
      }
      function $() {
        return this.bodyUsed = !1, this._initBody = function(l) {
          this._bodyInit = l, l ? typeof l == "string" ? this._bodyText = l : u.blob && Blob.prototype.isPrototypeOf(l) ? this._bodyBlob = l : u.formData && FormData.prototype.isPrototypeOf(l) ? this._bodyFormData = l : u.searchParams && URLSearchParams.prototype.isPrototypeOf(l) ? this._bodyText = l.toString() : u.arrayBuffer && u.blob && p(l) ? (this._bodyArrayBuffer = D(l.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : u.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(l) || d(l)) ? this._bodyArrayBuffer = D(l) : this._bodyText = l = Object.prototype.toString.call(l) : this._bodyText = "", this.headers.get("content-type") || (typeof l == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : u.searchParams && URLSearchParams.prototype.isPrototypeOf(l) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, u.blob && (this.blob = function() {
          var l = E(this);
          if (l)
            return l;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? E(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(U);
        }), this.text = function() {
          var l = E(this);
          if (l)
            return l;
          if (this._bodyBlob)
            return T(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(q(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, u.formData && (this.formData = function() {
          return this.text().then(x);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var K = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function ne(l) {
        var g = l.toUpperCase();
        return K.indexOf(g) > -1 ? g : l;
      }
      function G(l, g) {
        g = g || {};
        var b = g.body;
        if (l instanceof G) {
          if (l.bodyUsed)
            throw new TypeError("Already read");
          this.url = l.url, this.credentials = l.credentials, g.headers || (this.headers = new v(l.headers)), this.method = l.method, this.mode = l.mode, this.signal = l.signal, !b && l._bodyInit != null && (b = l._bodyInit, l.bodyUsed = !0);
        } else
          this.url = String(l);
        if (this.credentials = g.credentials || this.credentials || "same-origin", (g.headers || !this.headers) && (this.headers = new v(g.headers)), this.method = ne(g.method || this.method || "GET"), this.mode = g.mode || this.mode || null, this.signal = g.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && b)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(b);
      }
      G.prototype.clone = function() {
        return new G(this, { body: this._bodyInit });
      };
      function x(l) {
        var g = new FormData();
        return l.trim().split("&").forEach(function(b) {
          if (b) {
            var F = b.split("="), H = F.shift().replace(/\+/g, " "), M = F.join("=").replace(/\+/g, " ");
            g.append(decodeURIComponent(H), decodeURIComponent(M));
          }
        }), g;
      }
      function te(l) {
        var g = new v(), b = l.replace(/\r?\n[\t ]+/g, " ");
        return b.split(/\r?\n/).forEach(function(F) {
          var H = F.split(":"), M = H.shift().trim();
          if (M) {
            var ue = H.join(":").trim();
            g.append(M, ue);
          }
        }), g;
      }
      $.call(G.prototype);
      function X(l, g) {
        g || (g = {}), this.type = "default", this.status = g.status === void 0 ? 200 : g.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in g ? g.statusText : "OK", this.headers = new v(g.headers), this.url = g.url || "", this._initBody(l);
      }
      $.call(X.prototype), X.prototype.clone = function() {
        return new X(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new v(this.headers),
          url: this.url
        });
      }, X.error = function() {
        var l = new X(null, { status: 0, statusText: "" });
        return l.type = "error", l;
      };
      var Se = [301, 302, 303, 307, 308];
      X.redirect = function(l, g) {
        if (Se.indexOf(g) === -1)
          throw new RangeError("Invalid status code");
        return new X(null, { status: g, headers: { location: l } });
      }, c.DOMException = i.DOMException;
      try {
        new c.DOMException();
      } catch {
        c.DOMException = function(g, b) {
          this.message = g, this.name = b;
          var F = Error(g);
          this.stack = F.stack;
        }, c.DOMException.prototype = Object.create(Error.prototype), c.DOMException.prototype.constructor = c.DOMException;
      }
      function Y(l, g) {
        return new Promise(function(b, F) {
          var H = new G(l, g);
          if (H.signal && H.signal.aborted)
            return F(new c.DOMException("Aborted", "AbortError"));
          var M = new XMLHttpRequest();
          function ue() {
            M.abort();
          }
          M.onload = function() {
            var ce = {
              status: M.status,
              statusText: M.statusText,
              headers: te(M.getAllResponseHeaders() || "")
            };
            ce.url = "responseURL" in M ? M.responseURL : ce.headers.get("X-Request-URL");
            var me = "response" in M ? M.response : M.responseText;
            b(new X(me, ce));
          }, M.onerror = function() {
            F(new TypeError("Network request failed"));
          }, M.ontimeout = function() {
            F(new TypeError("Network request failed"));
          }, M.onabort = function() {
            F(new c.DOMException("Aborted", "AbortError"));
          }, M.open(H.method, H.url, !0), H.credentials === "include" ? M.withCredentials = !0 : H.credentials === "omit" && (M.withCredentials = !1), "responseType" in M && u.blob && (M.responseType = "blob"), H.headers.forEach(function(ce, me) {
            M.setRequestHeader(me, ce);
          }), H.signal && (H.signal.addEventListener("abort", ue), M.onreadystatechange = function() {
            M.readyState === 4 && H.signal.removeEventListener("abort", ue);
          }), M.send(typeof H._bodyInit > "u" ? null : H._bodyInit);
        });
      }
      return Y.polyfill = !0, i.fetch || (i.fetch = Y, i.Headers = v, i.Request = G, i.Response = X), c.Headers = v, c.Request = G, c.Response = X, c.fetch = Y, Object.defineProperty(c, "__esModule", { value: !0 }), c;
    })({});
  })(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
  var s = r;
  e = s.fetch, e.default = s.fetch, e.fetch = s.fetch, e.Headers = s.Headers, e.Request = s.Request, e.Response = s.Response, n.exports = e;
})(et, et.exports);
var hr = et.exports;
const Lt = /* @__PURE__ */ Vt(hr);
var pr = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.post = function(e, t) {
      var r = JSON.stringify(t), s = {
        method: "POST",
        body: r,
        keepalive: !0
      };
      return typeof window < "u" && window.fetch ? window.fetch(e, s) : Lt(e, s);
    }, n.prototype.get = function(e) {
      var t = {
        method: "GET",
        mode: "no-cors"
      };
      return typeof window < "u" && window.fetch ? window.fetch(e, t) : Lt(e, t);
    }, n;
  }()
), At = globalThis && globalThis.__assign || function() {
  return At = Object.assign || function(n) {
    for (var e, t = 1, r = arguments.length; t < r; t++) {
      e = arguments[t];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);
    }
    return n;
  }, At.apply(this, arguments);
};
globalThis && globalThis.__awaiter;
globalThis && globalThis.__generator;
globalThis && globalThis.__rest;
var Dt;
(function(n) {
  n.AllTabNavigation = "ALL_TAB_NAVIGATION", n.VerticalTabNavigation = "VERTICAL_TAB_NAVIGATION", n.ScrollToBottomOfPage = "SCROLL_TO_BOTTOM_OF_PAGE", n.QuestionFocus = "QUESTION_FOCUS", n.QuestionSubmit = "QUESTION_SUBMIT", n.RowExpand = "ROW_EXPAND", n.RowCollapse = "ROW_COLLAPSE", n.ThumbsUp = "THUMBS_UP", n.ThumbsDown = "THUMBS_DOWN", n.VoiceStart = "VOICE_START", n.VoiceStop = "VOICE_STOP", n.SearchBarImpression = "SEARCH_BAR_IMPRESSION", n.SearchClearButton = "SEARCH_CLEAR_BUTTON", n.Paginate = "PAGINATE", n.AutocompleteSelection = "AUTO_COMPLETE_SELECTION", n.VerticalViewAll = "VERTICAL_VIEW_ALL", n.CtaClick = "CTA_CLICK", n.TitleClick = "TITLE_CLICK", n.TapToCall = "TAP_TO_CALL", n.OrderNow = "ORDER_NOW", n.AddToCart = "ADD_TO_CART", n.ApplyNow = "APPLY_NOW", n.DrivingDirections = "DRIVING_DIRECTIONS", n.ViewWebsite = "VIEW_WEBSITE", n.Email = "EMAIL", n.BookAppointment = "BOOK_APPOINTMENT", n.Rsvp = "RSVP", n.ResultsHidden = "RESULTS_HIDDEN", n.ResultsUnhidden = "RESULTS_UNHIDDEN", n.FollowUpQuery = "FOLLOW_UP_QUERY";
})(Dt || (Dt = {}));
var ee;
(function(n) {
  n.PageView = "PAGE_VIEW", n.CTA = "CTA_CLICK", n.Website = "WEBSITE", n.DrivingDirection = "DRIVING_DIRECTIONS", n.PhoneCall = "CALL";
})(ee || (ee = {}));
ee.CTA;
ee.Website;
ee.DrivingDirection;
var fr = {
  eventType: ee.PageView
};
ee.PhoneCall;
var Me = "_yfpc", Ye = "__temp__", Wt = "y_source", tt = "realtimeanalytics.yext.com";
function zt() {
  return Date.now() + Math.floor(1e3 * Math.random());
}
var qe = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function s(i) {
    return i instanceof t ? i : new t(function(c) {
      c(i);
    });
  }
  return new (t || (t = Promise))(function(i, c) {
    function u(d) {
      try {
        a(r.next(d));
      } catch (f) {
        c(f);
      }
    }
    function p(d) {
      try {
        a(r.throw(d));
      } catch (f) {
        c(f);
      }
    }
    function a(d) {
      d.done ? i(d.value) : s(d.value).then(u, p);
    }
    a((r = r.apply(n, e || [])).next());
  });
}, Ke = globalThis && globalThis.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, c;
  return c = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (c[Symbol.iterator] = function() {
    return this;
  }), c;
  function u(a) {
    return function(d) {
      return p([a, d]);
    };
  }
  function p(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return t.label++, { value: a[1], done: !1 };
          case 5:
            t.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              t = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              t.label = a[1];
              break;
            }
            if (a[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a = e.call(n, t);
      } catch (d) {
        a = [6, d], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
}, gr = "conversiontracking/conversion", mr = "listings", _r = (
  /** @class */
  function() {
    function n(e, t) {
      this.httpRequesterService = e, this.debug = t, this._debug = t;
    }
    return n.prototype.printEvent = function(e, t) {
      this._debug && console.log("%c[YextAnalytics]%c- Tracked ".concat(t, " event: ").concat(e), "background: white; color: blue;", "");
    }, n.prototype.handleRequest = function(e) {
      return qe(this, void 0, void 0, function() {
        var t, r;
        return Ke(this, function(s) {
          switch (s.label) {
            case 0:
              return [4, this.httpRequesterService.get(e.toString())];
            case 1:
              return t = s.sent(), t.status !== 200 && !(t.type === "opaqueredirect" || t.type === "opaque") ? [4, t.text()] : [3, 3];
            case 2:
              throw r = s.sent(), new Error(r);
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.formatBaseEvent = function(e, t) {
      t.set(Me, e.cookieId), e.referrer && t.set("referrer", e.referrer), t.set("v", zt().toString()), t.set("location", e.location);
    }, n.prototype.trackConversion = function(e) {
      return qe(this, void 0, void 0, function() {
        var t, r;
        return Ke(this, function(s) {
          switch (s.label) {
            case 0:
              return t = new URL("https://".concat(tt, "/").concat(gr)), r = new URLSearchParams(), r.set("cid", e.cid), e.cv && r.set("cv", e.cv), n.formatBaseEvent(e, r), t.search = r.toString(), [4, this.handleRequest(t.toString())];
            case 1:
              return s.sent(), this.printEvent(e.cid, "Conversion"), [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.trackListings = function(e) {
      return qe(this, void 0, void 0, function() {
        var t, r;
        return Ke(this, function(s) {
          switch (s.label) {
            case 0:
              return t = new URL("https://".concat(tt, "/").concat(mr)), r = new URLSearchParams(), r.set(Wt, e.source), n.formatBaseEvent(e, r), t.search = r.toString(), [4, this.handleRequest(t.toString())];
            case 1:
              return s.sent(), this.printEvent(e.source, "Listings Click"), [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.setDebugEnabled = function(e) {
      this._debug = e;
    }, n;
  }()
), Bt = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function s(i) {
    return i instanceof t ? i : new t(function(c) {
      c(i);
    });
  }
  return new (t || (t = Promise))(function(i, c) {
    function u(d) {
      try {
        a(r.next(d));
      } catch (f) {
        c(f);
      }
    }
    function p(d) {
      try {
        a(r.throw(d));
      } catch (f) {
        c(f);
      }
    }
    function a(d) {
      d.done ? i(d.value) : s(d.value).then(u, p);
    }
    a((r = r.apply(n, e || [])).next());
  });
}, Nt = globalThis && globalThis.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, c;
  return c = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (c[Symbol.iterator] = function() {
    return this;
  }), c;
  function u(a) {
    return function(d) {
      return p([a, d]);
    };
  }
  function p(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return t.label++, { value: a[1], done: !1 };
          case 5:
            t.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              t = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              t.label = a[1];
              break;
            }
            if (a[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a = e.call(n, t);
      } catch (d) {
        a = [6, d], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
}, vr = "www.yext-pixel.com", wr = "sites", Ht = "store_pagespixel", N;
(function(n) {
  n.BusinessId = "businessids", n.Product = "product", n.SiteId = "siteId", n.IsStaging = "isStaging", n.CacheBuster = "v", n.UrlPath = "pageurl", n.Referrer = "pagesReferrer", n.EventType = "eventType", n.PageSetId = "pageSetId", n.EntityInternalId = "ids", n.DirectoryId = "directoryId", n.SearchId = "searchId", n.StaticPageId = "staticPageId", n.PageType = "pageType", n.VisitorId = "visitorId", n.VisitorMethod = "visitorIdMethod", n.PageDomain = "pageDomain";
})(N || (N = {}));
var Ce = /* @__PURE__ */ new Map();
Ce.set(ee.PageView, "pageview");
Ce.set(ee.CTA, "calltoactionclick");
Ce.set(ee.PhoneCall, "phonecall");
Ce.set(ee.DrivingDirection, "drivingdirection");
Ce.set(ee.Website, "clicktowebsite");
function yr(n) {
  var e = Ce.get(n);
  return typeof e == "string" ? e : n;
}
var br = (
  /** @class */
  function() {
    function n(e, t) {
      this.config = e, this.httpRequesterService = t, this.setVisitor(e.visitor), this._debug = e.debug, this._conversionTracker = new _r(this.httpRequesterService, this._debug), this._hasTrackedListings = !1;
      try {
        this._pageUrl = new URL(e.pageUrl);
      } catch {
        throw new Error("pageUrl property must be a valid URL, was: '".concat(e.pageUrl, "'"));
      }
      if (e.pageDomain)
        try {
          this._pageDomain = new URL(e.pageDomain);
        } catch {
          console.warn("pageDomain '".concat(e.pageDomain, "' is not a valid URL."), "It will not be included as a query param sent to the API.");
        }
    }
    return n.prototype.printEvent = function(e) {
      this._debug && console.log("%c[YextAnalytics]%c- Tracked Pages event: ".concat(e.eventType), "background: white; color: blue;", "");
    }, n.prototype.urlParameters = function(e) {
      var t = new URLSearchParams();
      return t.set(N.BusinessId, this.config.businessId.toString()), t.set(N.Product, wr), t.set(N.SiteId, this.config.siteId.toString()), t.set(N.IsStaging, (!this.config.production).toString()), t.set(N.EventType, yr(e.eventType)), t.set(N.PageType, this.config.pageType.name), this.config.pageType.name === "entity" ? (t.set(N.PageSetId, this.config.pageType.pageSetId), t.set(N.EntityInternalId, this.config.pageType.id.toString())) : this.config.pageType.name === "directory" ? (t.set(N.DirectoryId, this.config.pageType.directoryId), t.set(N.EntityInternalId, this.config.pageType.id.toString())) : this.config.pageType.name === "locator" ? t.set(N.SearchId, this.config.pageType.searchId) : N.StaticPageId in this.config.pageType && t.set(N.StaticPageId, this.config.pageType.staticPageId), t.set(N.CacheBuster, zt().toString()), t.set(N.UrlPath, this._pageUrl.pathname), t.set(N.Referrer, this.config.referrer), this._pageDomain && t.set(N.PageDomain, this._pageDomain.toString()), this._conversionTrackingEnabled && this._cookieID && t.set(Me, this._cookieID), this._visitor && (t.set(N.VisitorId, this._visitor.id), this._visitor.idMethod && t.set(N.VisitorMethod, this._visitor.idMethod)), t;
    }, n.prototype.pageView = function() {
      return Bt(this, void 0, void 0, function() {
        var e;
        return Nt(this, function(t) {
          switch (t.label) {
            case 0:
              return e = this._pageUrl.searchParams.get(Wt), this._conversionTrackingEnabled && this._cookieID && !this._hasTrackedListings && e ? [4, this._conversionTracker.trackListings({
                cookieId: this._cookieID,
                location: this._pageUrl.toString(),
                source: e
              })] : [3, 2];
            case 1:
              t.sent(), this._hasTrackedListings = !0, t.label = 2;
            case 2:
              return [2, this.track(fr)];
          }
        });
      });
    }, n.prototype.endpoint = function() {
      return this._conversionTrackingEnabled ? "https://".concat(tt, "/").concat(Ht) : "https://".concat(vr, "/").concat(Ht);
    }, n.prototype.track = function(e, t) {
      return Bt(this, void 0, void 0, function() {
        var r, s, i;
        return Nt(this, function(c) {
          switch (c.label) {
            case 0:
              return r = new URL(this.endpoint()), r.search = this.urlParameters(e).toString(), [4, this.httpRequesterService.get(r.toString())];
            case 1:
              return s = c.sent(), s.status !== 200 && !(s.type == "opaque" || s.type == "opaqueredirect") ? [4, s.text()] : [3, 3];
            case 2:
              throw i = c.sent(), new Error(i);
            case 3:
              return this.printEvent(e), this._conversionTrackingEnabled && this._cookieID && t ? [4, this._conversionTracker.trackConversion({
                cid: t.cid,
                cv: t.cv,
                cookieId: this._cookieID,
                location: this._pageUrl.toString()
              })] : [3, 5];
            case 4:
              c.sent(), c.label = 5;
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.setDebugEnabled = function(e) {
      this._debug = e, this._conversionTracker && this._conversionTracker.setDebugEnabled(e);
    }, n.prototype.setVisitor = function(e) {
      this._visitor = e;
    }, n.prototype.setConversionTrackingEnabled = function(e, t) {
      this._conversionTrackingEnabled = e, this._cookieID = t;
    }, n;
  }()
), Cr = (
  /** @class */
  function() {
    function n(e, t) {
      e === void 0 && (e = window), t === void 0 && (t = document), this._outerWindow = e, this._outerDocument = t;
    }
    return n.prototype.setAndGetYextCookie = function() {
      var e = this.fetchCookie();
      return e || (e = n.generateRandomCookie().toString()), this.setCookieAndRemoveOldCookies(e), e;
    }, n.generateRandomCookie = function() {
      return Math.floor(Math.random() * (/* @__PURE__ */ new Date()).getTime());
    }, n.prototype.fetchCookie = function() {
      var e = this, t = "", r = function(s) {
        if (e.canSetCookieWithDomain(s)) {
          var i = e.removeCookieByDomain(s);
          return i && (t = i, e.setCookie(t, s)), !0;
        }
      };
      return this.forEachDomainIncreasingSpecificity(r), t || r(""), t;
    }, n.prototype.forEachDomainIncreasingSpecificity = function(e) {
      for (var t = !1, r = this._outerDocument.location.hostname.split(".").reverse(), s = "", i = 0; i < r.length; i++)
        if (s = "." + r[i] + s, e(s)) {
          t = !0;
          break;
        }
      t || e("");
    }, n.prototype.removeCookieByDomain = function(e) {
      var t = this.persistentCookies();
      this.clearCookie(e);
      var r = this.persistentCookies();
      return r.length < t.length && n.listDifference(t, r)[0] || "";
    }, n.listDifference = function(e, t) {
      for (var r = Array.from(e), s = 0; s < t.length; s++) {
        var i = r.indexOf(t[s]);
        i !== -1 && r.splice(i, 1);
      }
      return r;
    }, n.prototype.persistentCookies = function() {
      return this.allCookies().filter(function(e) {
        return e !== Ye;
      });
    }, n.prototype.allCookies = function() {
      var e = [];
      return this.forEachCookieNameValue(function(t, r) {
        t === Me && e.push(r);
      }), e;
    }, n.prototype.forEachCookieNameValue = function(e) {
      this._outerDocument.cookie.split(";").forEach(function(t) {
        var r = t.split("="), s = r[0], i = r[1];
        s && i && e(s.trim(), i.trim());
      });
    }, n.prototype.setCookieAndRemoveOldCookies = function(e) {
      var t = this, r = !1, s = this.allCookies().length, i = 0;
      this.forEachDomainIncreasingSpecificity(function(c) {
        if (r ? t.removeCookieByDomain(c) && i++ : t.canSetCookieWithDomain(c) && (t.removeCookieByDomain(c) && i++, t.setCookie(e, c), r = !0), i >= s && r)
          return !0;
      });
    }, n.prototype.canSetCookieWithDomain = function(e) {
      var t = this.removeCookieByDomain(e), r = this.allCookies();
      this.setCookie(Ye, e);
      var s = this.allCookies();
      return r.length < s.length ? (t ? this.setCookie(t, e) : this.clearCookie(e), !0) : !1;
    }, n.prototype.setCookie = function(e, t) {
      this._outerDocument.cookie = this.formatCookie(Me, e, t);
    }, n.prototype.formatCookie = function(e, t, r, s) {
      s === void 0 && (s = "/");
      var i = e + "=" + t, c = /* @__PURE__ */ new Date();
      return c.setTime(c.getTime() + 90 * 24 * 60 * 60 * 1e3), i += ";path=" + s, i += ";expires=" + c.toUTCString(), r && (i += ";domain=" + r), i += ";samesite=None;", this._outerWindow.location.protocol === "https:" && (i += " Secure "), i;
    }, n.prototype.clearCookie = function(e, t) {
      e === void 0 && (e = ""), t === void 0 && (t = "/");
      var r = /* @__PURE__ */ new Date(0), s = Me + "=" + Ye;
      s += ";path=" + t, s += ";expires=" + r.toUTCString(), e && (s += ";domain=" + e + ";"), s += ";samesite=None;", this._outerWindow.location.protocol === "https:" && (s += " Secure "), this._outerDocument.cookie = s;
    }, n;
  }()
);
function Er(n) {
  var e = new pr();
  return new br(n, e);
}
function Yt(n) {
  return n.toLowerCase().trim().replace(/[^\w\s-]|[\s-]+/g, "");
}
function nt(n, e) {
  return [n, e].filter((t) => !!t).map((t) => Yt(t)).join("_");
}
class Pr {
  /**
   * Creates an Analytics instance, will fire a pageview event if requireOptin
   * is false
   *
   * @param templateData - template data object from the pages system
   * @param requireOptIn - boolean, set to true if you require user opt in before tracking analytics
   */
  constructor(e, t, r) {
    re(this, "_optedIn");
    re(this, "_conversionTrackingEnabled", !1);
    re(this, "_cookieManager");
    re(this, "_analyticsReporter");
    re(this, "_pageViewFired", !1);
    re(this, "_enableDebugging", !1);
    this.templateData = e, this.pageDomain = r, this._optedIn = !t, this.makeReporter(), this.pageView();
  }
  calculatePageType() {
    var s, i, c, u;
    const e = !!((i = (s = this.templateData.document) == null ? void 0 : s.__) != null && i.staticPage), t = !!((u = (c = this.templateData.document) == null ? void 0 : c.__) != null && u.entityPageSet);
    let r;
    if (e)
      r = {
        name: "static",
        staticPageId: this.templateData.document.__.name
      };
    else if (t)
      r = {
        name: "entity",
        pageSetId: this.templateData.document.__.name,
        id: this.templateData.document.uid
      };
    else
      throw new Error("invalid document type");
    return r;
  }
  makeReporter() {
    var t, r, s, i;
    if (ye().name !== "browser" || !this._optedIn)
      return;
    const e = Ot((r = (t = this.templateData) == null ? void 0 : t.document) == null ? void 0 : r.siteInternalHostName) || Ot((i = (s = this.templateData) == null ? void 0 : s.document) == null ? void 0 : i.siteDomain);
    this._analyticsReporter = Er({
      businessId: this.templateData.document.businessId,
      pageType: this.calculatePageType(),
      pageUrl: window.location.href,
      production: e,
      referrer: document.referrer,
      siteId: this.templateData.document.siteId,
      pageDomain: this.pageDomain
    }), this.setDebugEnabled(this._enableDebugging);
  }
  canTrack() {
    return ye().name === "browser" && this._optedIn && !!this._analyticsReporter;
  }
  setupConversionTracking() {
    var e;
    this._cookieManager = new Cr(), (e = this._analyticsReporter) == null || e.setConversionTrackingEnabled(
      !0,
      this._cookieManager.setAndGetYextCookie()
    );
  }
  /** {@inheritDoc AnalyticsMethods.enableConversionTracking} */
  enableTrackingCookie() {
    this._conversionTrackingEnabled = !0, this.canTrack() && this.setupConversionTracking();
  }
  /** {@inheritDoc AnalyticsMethods.identify} */
  identify(e) {
    var t;
    this.canTrack() && ((t = this._analyticsReporter) == null || t.setVisitor(e));
  }
  /** {@inheritDoc AnalyticsMethods.async} */
  async optIn() {
    this._optedIn = !0, this.makeReporter(), this._conversionTrackingEnabled && !this._cookieManager && this.setupConversionTracking(), this._pageViewFired || await this.pageView();
  }
  /** {@inheritDoc AnalyticsMethods.async} */
  async pageView() {
    var e;
    if (!this.canTrack())
      return Promise.resolve(void 0);
    await ((e = this._analyticsReporter) == null ? void 0 : e.pageView()), this._pageViewFired = !0;
  }
  /** {@inheritDoc AnalyticsMethods.track} */
  async track(e, t) {
    var r;
    if (!this.canTrack())
      return Promise.resolve();
    await ((r = this._analyticsReporter) == null ? void 0 : r.track(
      { eventType: Yt(e) },
      t
    ));
  }
  /** {@inheritDoc AnalyticsMethods.setDebugEnabled} */
  setDebugEnabled(e) {
    var t;
    this._enableDebugging = e, (t = this._analyticsReporter) == null || t.setDebugEnabled(e);
  }
  /** {@inheritDoc AnalyticsMethods.trackClick} */
  trackClick(e, t) {
    return (r) => {
      if (!this.canTrack())
        return Promise.resolve();
      if (r.target === null || r.defaultPrevented)
        return this.track(e, t);
      const s = r.target;
      if (s.href === null || s.href === void 0)
        return this.track(e, t);
      const i = new URL(s.href);
      if (i.protocol === "mailto:" || i.protocol === "tel:" || i.protocol === "javascript:" || i.hostname === window.location.hostname)
        return this.track(e, t);
      if (s.target && !s.target.match(/^_(self|parent|top)$/i) || r.ctrlKey || r.shiftKey || r.metaKey)
        return this.track(e, t);
      r.preventDefault();
      const u = () => {
        window.location.assign(i);
      }, p = new Promise((a) => {
        setTimeout(() => {
          a();
        }, 1e3);
      });
      return Promise.race([this.track(e, t), p]).then(u).catch(u);
    };
  }
}
const qt = ot(null), Kt = ke.createContext({ name: "" }), Xt = () => ke.useContext(Kt).name;
function Ii(n) {
  const e = Xt(), t = nt(e, n.name);
  return /* @__PURE__ */ R.jsx(Kt.Provider, { value: { name: t }, children: n.children });
}
function Ne() {
  const n = we(qt);
  if (!n)
    return n;
  ye().name === "browser" && !window.setAnalyticsOptIn && (window.setAnalyticsOptIn = async () => {
    await n.optIn();
  });
  const e = Xt();
  return {
    trackClick(t, r) {
      return n.trackClick(nt(e, t), r);
    },
    setDebugEnabled(t) {
      return n.setDebugEnabled(t);
    },
    enableTrackingCookie() {
      return n.enableTrackingCookie();
    },
    identify(t) {
      return n.identify(t);
    },
    optIn() {
      return n.optIn();
    },
    pageView() {
      return n.pageView();
    },
    track(t, r) {
      return n.track(nt(e, t), r);
    }
  };
}
const Mi = () => {
  var n;
  return (n = Ne()) == null ? void 0 : n.track;
}, ki = () => {
  var n;
  return (n = Ne()) == null ? void 0 : n.pageView;
}, Si = () => {
  var n;
  return (n = Ne()) == null ? void 0 : n.identify;
};
function xi(n) {
  var d;
  const {
    children: e,
    requireOptIn: t,
    enableTrackingCookie: r,
    enableDebugging: s,
    templateData: i,
    pageDomain: c
  } = n, u = at(null);
  u.current === null && (u.current = new Pr(
    i,
    t,
    c
  ));
  const p = u.current;
  r && p.enableTrackingCookie();
  let a = Tr();
  return ye().name === "node" && (a = a || ((d = process.env) == null ? void 0 : d.NODE_ENV) === "development"), p.setDebugEnabled(s ?? a), /* @__PURE__ */ R.jsx(qt.Provider, { value: p, children: e });
}
function Tr() {
  return ye().name !== "browser" || typeof window === void 0 ? !1 : !!new URL(window.location.href).searchParams.get("xYextDebug");
}
const he = {
  /**
   * The the default layout if one is not specified. An image will be scaled down to fit the
   * container but not exceed the absolute size of the image.
   */
  INTRINSIC: "intrinsic",
  /**
   * Shows the image in a fixed size. `width` or `height` must be passed in. If both "width` and
   * `height` are passed in, but the aspect ratio does not match the aspect ratio of the image,
   * the image will be centered. This behavior can be adjusted using the `objectFit` and
   * `objectPosition` props of the `style` rpop.
   */
  FIXED: "fixed",
  /** Shows the image in a fixed aspect ratio. The `aspectRatio` prop must be provided. */
  ASPECT: "aspect",
  /** Always fills the image to 100% of the container's width. */
  FILL: "fill"
}, Jt = /(https?:\/\/a.mktgcdn.com\/p(?<env>-sandbox|-qa|-dev)?\/)(?<uuid>.+)\/(.*)/, Oi = ({
  image: n,
  className: e,
  width: t,
  height: r,
  aspectRatio: s,
  layout: i = he.INTRINSIC,
  placeholder: c,
  imgOverrides: u,
  style: p = {},
  loading: a = "lazy"
}) => {
  const d = at(null), [f, _] = ie(!1), y = "image" in n ? n.image : n;
  ae(() => {
    var x;
    (x = d.current) != null && x.complete && _(!0);
  }, []), Rr(
    i,
    y.width,
    y.height,
    t,
    r,
    s
  );
  const v = Math.abs(y.width);
  v || console.warn("Invalid image width.");
  const E = Math.abs(y.height);
  E || console.warn("Invalid image height.");
  const A = Ir(y.url);
  if (!A)
    return /* @__PURE__ */ R.jsx(R.Fragment, { children: c != null && c });
  const U = t && t > 0 ? t : void 0, T = r && r > 0 ? r : void 0, { src: q, imgStyle: D, widths: $ } = kr(
    i,
    v,
    E,
    A,
    p,
    y.url,
    U,
    T,
    s
  ), K = $.map(
    (x) => `${rt(
      A,
      x,
      E / v * x,
      y.url
    )} ${x}w`
  ).join(", "), ne = [640, 768, 1024, 1280, 1536], G = $.map(
    (x, te) => te === $.length - 1 ? `${x}px` : `(max-width: ${ne[te]}px) ${x}px`
  ).join(", ");
  return /* @__PURE__ */ R.jsxs(R.Fragment, { children: [
    !f && c != null && c,
    /* @__PURE__ */ R.jsx(
      "img",
      {
        ref: d,
        style: D,
        src: q,
        className: e,
        width: U,
        height: T,
        srcSet: K,
        sizes: G,
        loading: a,
        alt: y.alternateText || "",
        ...u
      }
    )
  ] });
}, Rr = (n, e, t, r, s, i) => {
  if (e < 0 && console.warn(`Invalid image width: ${e}.`), t < 0 && console.warn(`Invalid image height: ${t}.`), n == he.FIXED) {
    if (!r && !s) {
      console.warn(
        "Using fixed layout but neither width nor height is passed as props."
      );
      return;
    }
    r && r < 0 && console.warn(`Using fixed layout but width is invalid: ${r}.`), s && s < 0 && console.warn(`Using fixed layout but height is invalid: ${s}.`);
    return;
  }
  (r || s) && console.warn(
    "Width or height is passed in but layout is not fixed. These will have no impact. If you want to have a fixed height or width then set layout to fixed."
  ), n == he.ASPECT && !i && console.warn(
    "Using aspect layout but aspectRatio is not passed as a prop."
  );
}, Ir = (n) => {
  var t;
  const e = n.match(Jt);
  return (t = e == null ? void 0 : e.groups) != null && t.uuid ? e.groups.uuid : (console.error(`Invalid image url: ${n}.`), "");
}, Mr = (n) => {
  var t;
  const e = n.match(Jt);
  return (t = e == null ? void 0 : e.groups) == null ? void 0 : t.env;
}, rt = (n, e, t, r) => {
  const s = Mr(r);
  return `https://dynl.mktgcdn.com/${s ? `p${s}` : "p"}/${n}/${Math.round(
    e
  )}x${Math.round(t)}`;
}, kr = (n, e, t, r, s, i, c, u, p) => {
  let a = [100, 320, 640, 960, 1280, 1920], d = rt(r, 500, 500, i);
  const f = { ...s };
  switch (f.objectFit = f.objectFit || "cover", f.objectPosition = f.objectPosition || "center", n) {
    case he.INTRINSIC:
      f.maxWidth = e, f.width = "100%", f.aspectRatio = p ? `${p}` : `${e} / ${t}`;
      break;
    case he.FIXED: {
      const { fixedWidth: _, fixedHeight: y, fixedWidths: v } = Sr(
        e,
        t,
        a,
        c,
        u
      );
      f.width = _, f.height = y, a = v, d = rt(r, _, y, i);
      break;
    }
    case he.ASPECT:
      f.aspectRatio = p ? `${p}` : `${e} / ${t}`;
      break;
    case he.FILL:
      f.width = "100%", f.aspectRatio = p ? `${p}` : `${e} / ${t}`;
      break;
    default:
      console.warn(`Unrecognized layout: ${n}.`);
      break;
  }
  return { src: d, imgStyle: f, widths: a };
}, Sr = (n, e, t, r, s) => r && s ? {
  fixedWidth: r,
  fixedHeight: s,
  fixedWidths: [r]
} : r ? {
  fixedWidth: r,
  fixedHeight: r * e / n,
  fixedWidths: [r]
} : s ? {
  fixedWidth: s / e * n,
  fixedHeight: s,
  fixedWidths: [s / e * n]
} : {
  fixedWidth: n,
  fixedHeight: e,
  fixedWidths: t
};
var Qt = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(n) {
  (function() {
    var e = {}.hasOwnProperty;
    function t() {
      for (var r = [], s = 0; s < arguments.length; s++) {
        var i = arguments[s];
        if (i) {
          var c = typeof i;
          if (c === "string" || c === "number")
            r.push(i);
          else if (Array.isArray(i)) {
            if (i.length) {
              var u = t.apply(null, i);
              u && r.push(u);
            }
          } else if (c === "object") {
            if (i.toString !== Object.prototype.toString && !i.toString.toString().includes("[native code]")) {
              r.push(i.toString());
              continue;
            }
            for (var p in i)
              e.call(i, p) && i[p] && r.push(p);
          }
        }
      }
      return r.join(" ");
    }
    n.exports ? (t.default = t, n.exports = t) : window.classNames = t;
  })();
})(Qt);
var xr = Qt.exports;
const en = /* @__PURE__ */ Vt(xr), Or = (n) => n.linkType === "Email" || !n.linkType && tn(n.link) ? `mailto:${n.link}` : n.linkType === "Phone" ? `tel:${n.link}` : n.link, tn = (n) => /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(n), Lr = (n) => {
  let e = "";
  for (let t = n.length - 1; t >= 0; e += n[t--])
    ;
  return e;
}, Ar = (n) => "href" in n, Dr = ke.forwardRef(
  function(e, t) {
    const r = Ar(e) ? { link: e.href } : e.cta, { children: s, onClick: i, className: c, eventName: u, cta: p, ...a } = e, d = u || (p ? "cta" : "link"), f = Ne(), _ = e.obfuscate || e.obfuscate !== !1 && tn(r.link), [y, v] = ie(!1), E = async (D) => {
      if (v(!0), f !== null)
        try {
          await f.trackClick(d, e.conversionDetails)(D);
        } catch {
          console.error("Failed to report click Analytics Event");
        }
      i && i(D);
    }, A = !s && !r.label, U = !y && _, T = {
      ...e.style,
      unicodeBidi: "bidi-override",
      direction: A && U ? "rtl" : "ltr"
    }, q = U ? Lr(r.link) : r.link;
    return /* @__PURE__ */ R.jsx(
      "a",
      {
        className: en("Link", c),
        href: y || !_ ? Or(r) : "obfuscate",
        onClick: E,
        rel: e.target && !e.rel ? "noopener" : void 0,
        ref: t,
        style: T,
        ...a,
        children: s || r.label || q
      }
    );
  }
), Li = {
  URL: "URL",
  Email: "Email",
  Phone: "Phone"
}, O = Object.freeze({
  DEGREE: Symbol("deg"),
  KILOMETER: Symbol("km"),
  MILE: Symbol("mi"),
  RADIAN: Symbol("r")
}), Q = Object.freeze({
  MERCATOR: Symbol("mercator"),
  SPHERICAL: Symbol("spherical")
}), Xe = 3959, Je = 6371, Br = ["latitude", "lat"], Nr = ["longitude", "lon", "lng", "long"];
function jt(n, e) {
  for (const t of e)
    if (n[t] || n[t] === 0)
      return n[t];
}
function Ut(n) {
  switch (typeof n) {
    case "string":
    case "number":
      const e = Number.parseFloat(n);
      if (Number.isNaN(e))
        throw new Error(`'${n}' must be convertible to a Number'`);
      return e;
    default:
      throw new Error(`typeof '${n}' must be a number or a string that can be converted to a number, is '${typeof n}'`);
  }
}
function pe(n) {
  return n * Math.PI / 180;
}
function oe(n) {
  return n / Math.PI * 180;
}
function Hr(n, e) {
  const t = pe(n.latitude), r = pe(e.latitude), s = r - t, i = pe(e.longitude - n.longitude), c = Math.pow(Math.sin(s / 2), 2) + Math.cos(t) * Math.cos(r) * Math.pow(Math.sin(i / 2), 2);
  return 2 * Math.atan2(Math.sqrt(c), Math.sqrt(1 - c));
}
function jr(n, e) {
  const t = Math.tan(Math.PI / 360 * (n + 90)), r = Math.tan(Math.PI / 360 * (e + 90));
  return Math.log(r / t);
}
function Ur(n, e) {
  const r = Math.tan(Math.PI / 360 * (n + 90)) * Math.pow(Math.E, e);
  return Math.atan(r) * 360 / Math.PI - 90;
}
class S {
  /**
   * Constructor takes either 1 or 2 arguments.
   * 2 arguments: latitude and longitude.
   * 1 argument: an object with at least one {@link module:@yext/components-geo~Coordinate~LATITUDE_ALIASES latitude alias}
   * and one one {@link module:@yext/components-geo~CoordinateCoordinate~LONGITUDE_ALIASES longitude alias}.
   * @param {number|Object} latitudeOrObject
   * @param {number} [longitude] Optional only if the first argument is a {@link module:@yext/components-geo~Coordinate Coordinate}-like object
   */
  constructor(e, t) {
    let r = e;
    typeof e == "object" && (r = jt(e, Br), t = jt(e, Nr), r = typeof r == "function" ? r() : r, t = typeof t == "function" ? t() : t), this.latitude = r, this.longitude = t;
  }
  /**
   * Degrees latitude in the range [-90, 90].
   * If setting a value outside this range, it will be set to -90 or 90, whichever is closer.
   * @type {number}
   */
  get latitude() {
    return this._lat;
  }
  /**
   * Degrees longitude in the range [-Infinity, Infinity].
   * @type {number}
   */
  get longitude() {
    return this._lon;
  }
  /**
   * Degrees longitude in the range [-180, 180).
   * If the coordinate's longitude is outside this range, the equivalent value within it is used.
   * Examples: 123 => 123, 270 => -90, -541 => 179
   * @type {number}
   */
  get normalLon() {
    return ((this._lon + 180) % 360 + 360) % 360 - 180;
  }
  set latitude(e) {
    this._lat = Math.max(-90, Math.min(Ut(e), 90));
  }
  set longitude(e) {
    this._lon = Ut(e);
  }
  /**
   * Add distance to the coordinate to change its position.
   * @param {number} latDist latitude distance
   * @param {number} lonDist longitude distance
   * @param {module:@yext/components-geo~Unit} [unit=Unit.DEGREE] The unit of latDist and lonDist
   * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL] The projection of Earth (not relevant when using a physical distance unit, e.g. Mile)
   */
  add(e, t, r = O.DEGREE, s = Q.SPHERICAL) {
    if (s == Q.MERCATOR && (r == O.DEGREE || r == O.RADIAN)) {
      const i = r == O.DEGREE ? pe(e) : e, c = r == O.DEGREE ? t : oe(t);
      this.latitude = Ur(this.latitude, i), this.longitude += c;
    } else
      switch (r) {
        case O.DEGREE:
          this.latitude += e, this.longitude += t;
          break;
        case O.KILOMETER:
          this.latitude += oe(e) * Je, this.longitude += oe(t) * Je * Math.cos(pe(this.latitude));
          break;
        case O.MILE:
          this.latitude += oe(e) * Xe, this.longitude += oe(t) * Xe * Math.cos(pe(this.latitude));
          break;
        case O.RADIAN:
          this.latitude += oe(e), this.longitude += oe(t);
          break;
      }
  }
  /**
   * Calculate the distance from this coordinate to another coordinate.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   * @param {module:@yext/components-geo~Unit} [unit=Unit.MILE] The unit of distance
   * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL] The projection of Earth (not relevant when using a physical distance unit, e.g. Mile)
   * @returns {number} Distance in the requested unit
   */
  distanceTo(e, t = O.MILE, r = Q.SPHERICAL) {
    if (r == Q.MERCATOR && (t == O.DEGREE || t == O.RADIAN)) {
      const s = jr(this.latitude, e.latitude), i = Math.abs(e.normalLon - this.normalLon), c = pe(Math.min(i, 360 - i)), u = Math.sqrt(Math.pow(s, 2) + Math.pow(c, 2));
      switch (t) {
        case O.DEGREE:
          return oe(u);
        case O.RADIAN:
          return u;
      }
    } else {
      const s = Hr(this, e);
      switch (t) {
        case O.DEGREE:
          return oe(s);
        case O.KILOMETER:
          return s * Je;
        case O.MILE:
          return s * Xe;
        case O.RADIAN:
          return s;
      }
    }
  }
  /**
   * Test if this coordinate has the same latitude and longitude as another.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   * @returns {boolean}
   */
  equals(e) {
    return e && e.latitude === this.latitude && e.longitude === this.longitude;
  }
  /**
   * Get the coordinate as a string that can be used in a search query.
   * Example: {latitude: -45, longitude: 123} => '-45,123'
   * @returns {string}
   */
  searchQueryString() {
    return `${this.latitude},${this.longitude}`;
  }
}
function nn(n, e = () => {
}) {
  const t = document.createElement("script");
  t.async = !0, t.onload = e, t.src = n, document.head.appendChild(t);
}
const V = {
  UNDEFINED: "undefined",
  NULL: "object",
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#null
  BOOLEAN: "boolean",
  NUMBER: "number",
  BIGINT: "bigint",
  STRING: "string",
  SYMBOL: "symbol",
  FUNCTION: "function",
  OBJECT: "object"
};
function z(n, e) {
  if (typeof e != "string")
    throw new Error("Assertion error: 'type' must be a string");
  if (typeof n !== e)
    throw new Error(`Expected an object of type '${e}' but received '${typeof n}'`);
}
function W(n, e) {
  let t;
  try {
    t = n instanceof e;
  } catch {
    throw new Error("Assertion error: 'instanceClass' is not a valid constructor");
  }
  if (!t)
    throw new Error(`Expected an instance of '${e.name}' but received '${n.constructor.name}'`);
}
class rn {
  /**
   * @param {module:@yext/components-maps~MapProvider} provider
   * @param {HTMLElement} wrapper The wrapper element that the map will be inserted into
   */
  constructor(e, t) {
    W(e, ge), W(t, HTMLElement), this.providerMapClass = e.getMapClass(), this.wrapper = t, this.controlEnabled = !0, this.panHandler = () => {
    }, this.panStartHandler = () => {
    }, this.providerOptions = {};
  }
  /**
   * @param {boolean} controlEnabled Whether the user can interact with the map
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withControlEnabled(e) {
    return this.controlEnabled = e, this;
  }
  /**
   * @param {function} panHandler Function called after the map bounds change
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withPanHandler(e) {
    return z(e, V.FUNCTION), this.panHandler = e, this;
  }
  /**
   * @param {function} panStartHandler Function called before the map bounds change
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withPanStartHandler(e) {
    return z(e, V.FUNCTION), this.panStartHandler = e, this;
  }
  /**
   * @param {Object} providerOptions A free-form object used to set any additional provider-specific
   *   options, usually by passing the object to the map's constructor
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withProviderOptions(e) {
    return this.providerOptions = e, this;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderMap} An instance of a subclass of {@link module:@yext/components-maps~ProviderMap ProviderMap}
   *   for the given {@link module:@yext/components-maps~MapProvider MapProvider}
   */
  build() {
    const e = this.providerMapClass;
    return new e(this);
  }
}
class Ee {
  /**
   * The constructor creates a map instance using the provider's API and initializes it with all the
   * given options. See {@link module:@yext/components-maps~ProviderMapOptions ProviderMapOptions}
   * for the supported options.
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(e) {
    W(e, rn), this._panHandler = e.panHandler, this._panStartHandler = e.panStartHandler;
  }
  /**
   * @returns {module:@yext/components-tsx-geo~Coordinate} The current center of the map
   */
  getCenter() {
    throw new Error("not implemented");
  }
  /**
   * Zoom level complies with the specifications in {@link module:@yext/components-maps~Map#getZoom Map#getZoom}
   * @returns {number} The current zoom level of the map
   */
  getZoom() {
    throw new Error("not implemented");
  }
  /**
   * @param {module:@yext/components-tsx-geo~Coordinate} coordinate The new center for the map
   * @param {boolean} animated Whether to transition smoothly to the new center
   */
  setCenter(e, t) {
    throw new Error("not implemented");
  }
  /**
   * Zoom level complies with the specifications in {@link module:@yext/components-maps~Map#getZoom Map#getZoom}
   * @param {number} zoom The new zoom level for the map
   * @param {boolean} animated Whether to transition smoothly to the new zoom
   */
  setZoom(e, t) {
    throw new Error("not implemented");
  }
  /**
   * @param {number} zoom
   * @param {Object} center Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} animated Whether to transition smoothly to the new bounds
   * @see module:@yext/components-maps~ProviderMap#setZoom
   * @see module:@yext/components-maps~ProviderMap#setCenter
   */
  setZoomCenter(e, t, r) {
    this.setZoom(e, r), this.setCenter(t, r);
  }
}
class sn {
  /**
   * @param {module:@yext/components-maps~MapProvider} provider
   */
  constructor(e) {
    W(e, ge), this.providerPinClass = e.getPinClass(), this.clickHandler = () => {
    }, this.focusHandler = (t) => {
    }, this.hoverHandler = (t) => {
    }, this.icons = {};
  }
  /**
   * @param {import('./mapPin.js').PinClickHandler} clickHandler Function called when the pin is clicked
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withClickHandler(e) {
    return z(e, V.FUNCTION), this.clickHandler = e, this;
  }
  /**
   * @param {import('./mapPin').PinFocusHandler} focusHandler Function called when the pin becomes (un)focused
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withFocusHandler(e) {
    return z(e, V.FUNCTION), this.focusHandler = e, this;
  }
  /**
   * @param {import('./mapPin.js').PinHoverHandler} hoverHandler Function called when the pin becomes (un)hovered
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withHoverHandler(e) {
    return z(e, V.FUNCTION), this.hoverHandler = e, this;
  }
  /**
   * Similar to {@link module:@yext/components-maps~MapPinOptions#withIcon MapPinOptions#withIcon},
   * but all icons are given as a map of key => icon. If a provider pin instance needs an icon to be
   * a specialized class rather than a simple URL, the icons in this object can be converted in this
   * function and assigned back to the icons object instead of being recreated from the URL every
   * time the pin's icon changes.
   * @param {Object<string,string>} icons Map of a string key to the URL or data URI of an image
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withIcons(e) {
    return this.icons = e, this;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderPin} An instance of a subclass of {@link module:@yext/components-maps~ProviderPin ProviderPin}
   *   for the given {@link module:@yext/components-maps~MapProvider MapProvider}
   */
  build() {
    const e = this.providerPinClass;
    return new e(this);
  }
}
class ct {
  /**
   * The constructor creates a pin instance using the provider's API and initializes it with all the
   * given options. See {@link module:@yext/components-maps~ProviderPinOptions ProviderPinOptions}
   * for the supported options.
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(e) {
    W(e, sn), this._clickHandler = e.clickHandler, this._focusHandler = e.focusHandler, this._hoverHandler = e.hoverHandler, this._icons = e.icons;
  }
  /**
   * @param {module:@yext/components-tsx-geo~Coordinate} coordinate The position of the pin
   */
  setCoordinate(e) {
    throw new Error("not implemented");
  }
  /**
   * Remove the pin from its current map and, if newMap is not null, add it to the new map.
   * @param {?module:@yext/components-maps~Map} newMap The new map -- if null, the pin will not be
   *   shown on any map
   * @param {?module:@yext/components-maps~Map} currentMap The current map -- if null, the pin is
   *   not shown on any map
   */
  setMap(e, t) {
    throw new Error("not implemented");
  }
  /**
   * Apply the given properties to modify the appearance of the pin.
   * @param {module:@yext/components-maps~PinProperties} pinProperties
   * @see module:@yext/components-maps~PinProperties
   */
  setProperties(e) {
    throw new Error("not implemented");
  }
}
const Fr = Object.freeze({
  backgroundPosition: "center",
  backgroundRepeat: "no-repeat",
  backgroundSize: "contain",
  left: "0",
  outline: "none",
  pointerEvents: "auto",
  position: "absolute",
  top: "0"
});
class He extends ct {
  /**
   * This is the base style applied to pin elements. It is a map from CSS property to value, such
   * as 'position': 'absolute'
   * @type {Object}
   */
  static get baseStyle() {
    return Fr;
  }
  /**
   * After instatiating a {@link module:@yext/components-maps~ProviderPin ProviderPin}, this creates
   * a wrapper element and a default pin element.
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(e) {
    super(e), this._pinEl = document.createElement("button"), Object.assign(this._pinEl.style, this.constructor.baseStyle), this._pinAlt = document.createElement("span"), this._pinAlt.classList.add("sr-only"), this._pinEl.appendChild(this._pinAlt), this._wrapper = document.createElement("div"), this._wrapper.style.pointerEvents = "none", this._wrapper.appendChild(this._pinEl), this.addListeners();
  }
  /**
   * Adds click, hover, and focus event listeners to the wrapper element
   */
  addListeners() {
    this._wrapper.addEventListener("click", () => this._clickHandler()), this._wrapper.addEventListener("focusin", () => this._focusHandler(!0)), this._wrapper.addEventListener("focusout", () => this._focusHandler(!1)), this._wrapper.addEventListener("mouseover", () => this._hoverHandler(!0)), this._wrapper.addEventListener("mouseout", () => this._hoverHandler(!1));
  }
  /**
   * @returns {HTMLElement} HTML button element for pin element
   */
  getPinElement() {
    return this._pinEl;
  }
  /**
   * @returns {HTMLElement} HTML button element for wrapper element
   */
  getWrapperElement() {
    return this._wrapper;
  }
  /**
   * @param {module:@yext/components-maps~PinProperties} pinProperties
   * @see module:@yext/components-maps~ProviderPin#setProperties
   */
  setProperties(e) {
    this.setElementProperties(e);
    const t = e.getClass(), r = e.getElement() || this._pinEl, s = e.getZIndex();
    r.style.pointerEvents = "auto", this._wrapper && (this._wrapper.style.zIndex = s, this._wrapper.setAttribute("class", t), r != this._wrapper.children[0] && (this._wrapper.children[0].style.pointerEvents = "", this._wrapper.removeChild(this._wrapper.children[0]), this._wrapper.appendChild(r)));
  }
  /**
   * Sets properties used specifically by the pin element
   * @param {module:@yext/components-maps~PinProperties} pinProperties
   */
  setElementProperties(e) {
    const t = e.getAnchorX(), r = e.getAnchorY(), s = e.getHeight(), i = this._icons[e.getIcon()], c = e.getSRText(), u = e.getWidth();
    Object.assign(this._pinEl.style, {
      backgroundImage: i ? `url("${i}")` : "",
      height: s + "px",
      transform: `translate(${-100 * t}%, ${-100 * r}%)`,
      width: u + "px"
    }), this._pinAlt.innerText = c;
  }
}
class fe {
  constructor() {
    this.loadFunction = (e, t, r, s) => e(), this.mapClass = Ee, this.pinClass = ct, this.providerName = "";
  }
  /**
   * @param {module:@yext/components-maps~ProviderLoadFunction} loadFunction
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withLoadFunction(e) {
    return z(e, V.FUNCTION), this.loadFunction = e, this;
  }
  /**
   * @param {module:@yext/components-maps~ProviderMap} mapClass Subclass of {@link module:@yext/components-maps~ProviderMap ProviderMap}
   *   for the provider
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withMapClass(e) {
    return this.mapClass = e, this;
  }
  /**
   * @param {module:@yext/components-maps~ProviderPin} pinClass Subclass of {@link module:@yext/components-maps~ProviderPin ProviderPin}
   *   for the provider
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withPinClass(e) {
    return this.pinClass = e, this;
  }
  /**
   * @param {string} providerName Name of the map provider
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withProviderName(e) {
    return this.providerName = e, this;
  }
  /**
   * @returns {module:@yext/components-maps~MapProvider}
   */
  build() {
    return new ge(this);
  }
}
class ge {
  /**
   * @param {module:@yext/components-maps~MapProviderOptions} options
   */
  constructor(e) {
    W(e, fe), this._loadFunction = e.loadFunction, this._mapClass = e.mapClass, this._pinClass = e.pinClass, this._providerName = e.providerName, this._loadPromise = new Promise((t, r) => {
      this._resolveLoad = t, this._rejectLoad = r;
    }), this._apiKey = "", this._loadInvoked = !1, this._loaded = !1, this._options = {};
  }
  /**
   * Returns true if the map provider has been successfully loaded
   * @type {boolean}
   */
  get loaded() {
    return this._loaded;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderMap}
   * @see module:@yext/components-maps~MapProviderOptions#withMapClass
   */
  getMapClass() {
    return this._mapClass;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderPin}
   * @see module:@yext/components-maps~MapProviderOptions#withPinClass
   */
  getPinClass() {
    return this._pinClass;
  }
  /**
   * @returns {string}
   * @see module:@yext/components-maps~MapProviderOptions#withProviderName
   */
  getProviderName() {
    return this._providerName;
  }
  /**
   * Call {@link module:@yext/components-maps~MapPinOptions~loadFunction MapPinOptions~loadFunction}
   * and resolve or reject when loading succeeds or fails
   * @async
   * @param {string} [apiKey] Provider API key -- uses value from {@link module:@yext/components-maps~MapProvider#setLoadOptions MapProvider#setLoadOptions}
   *   if not passed
   * @param {Object} [options] Additional provider-specific options -- uses value from {@link module:@yext/components-maps~MapProvider#setLoadOptions MapProvider#setLoadOptions}
   *   if not passed
   */
  async load(e = this._apiKey, t = this._options) {
    this._loadInvoked || (this._loadInvoked = !0, this._loadFunction(this._resolveLoad, this._rejectLoad, e, t)), await this.ready(), this._loaded = !0;
  }
  /**
   * Resolves or rejects when the map provider has loaded successfully or unsuccessfully
   * @async
   */
  async ready() {
    await this._loadPromise;
  }
  /**
   * Set the API key and provider options used on load. Does nothing if load was already called.
   * @param {string} apiKey Provider API key
   * @param {?Object} [options=null] Additional provider-specific options
   */
  setLoadOptions(e, t = null) {
    this._loadInvoked || (this._apiKey = e, this._options = t || this._options);
  }
}
const Ft = {
  GEOCODER: "geocoder",
  PLACES: "places"
};
class $r extends Ee {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(e) {
    super(e), this.map = new google.maps.Map(e.wrapper, {
      disableDefaultUI: !e.controlEnabled,
      fullscreenControl: !1,
      gestureHandling: e.controlEnabled ? "auto" : "none",
      mapTypeControl: !1,
      rotateControl: !1,
      scaleControl: !1,
      streetViewControl: !1,
      zoomControl: e.controlEnabled,
      zoomControlOptions: {
        position: google.maps.ControlPosition.RIGHT_TOP
      },
      ...e.providerOptions
    }), this._moving = !1, google.maps.event.addListener(this.map, "bounds_changed", () => {
      this._moving || (this._moving = !0, this._panStartHandler());
    }), google.maps.event.addListener(this.map, "idle", () => {
      this._moving = !1, this._panHandler();
    });
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new S(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom();
  }
  /**
   * @inheritdoc
   */
  setCenter(e, t) {
    const r = new google.maps.LatLng(e.latitude, e.longitude);
    t ? this.map.panTo(r) : this.map.setCenter(r);
  }
  /**
   * @inheritdoc
   */
  setZoom(e, t) {
    this.map.setZoom(Math.floor(e));
  }
  /**
   * @inheritdoc
   */
  setZoomCenter(e, t, r) {
    this.setCenter(t, r), this.setZoom(e, r);
  }
}
class Gr extends He {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(e) {
    super(e), this._wrapper.style.position = "absolute", google.maps.OverlayView.preventMapHitsAndGesturesFrom(this._wrapper);
    const t = this;
    class r extends google.maps.OverlayView {
      draw() {
        var c;
        const i = (c = this.getProjection()) == null ? void 0 : c.fromLatLngToDivPixel(t._latLng);
        i && (t._wrapper.style.left = i.x + "px", t._wrapper.style.top = i.y + "px");
      }
      onAdd() {
        this.getPanes().floatPane.appendChild(t._wrapper);
      }
      onRemove() {
        var i;
        (i = t._wrapper.parentNode) == null || i.removeChild(t._wrapper);
      }
    }
    this.pin = new r();
  }
  /**
   * @inheritdoc
   */
  setCoordinate(e) {
    this._latLng = new google.maps.LatLng(e.latitude, e.longitude), this.pin.draw();
  }
  /**
   * @inheritdoc
   */
  setMap(e, t) {
    this.pin.setMap(e ? e.getProviderMap().map : null);
  }
}
const $t = "GoogleMapsCallback_b7d77ff2", Zr = "https://maps.googleapis.com/maps/api/js";
function Vr(n, e, t, {
  autocomplete: r = !1,
  channel: s = window.location.hostname,
  client: i,
  language: c,
  libraries: u = [],
  params: p = {}
} = {}) {
  window[$t] = n, r && u.push(Ft.GEOCODER, Ft.PLACES);
  const a = {
    callback: $t,
    channel: s,
    language: c,
    libraries: u.join(","),
    ...p
  };
  t && (a.key = t), i && (a.client = i), nn(Zr + "?" + Object.entries(a).map(([d, f]) => d + "=" + f).join("&"));
}
const on = new fe().withLoadFunction(Vr).withMapClass($r).withPinClass(Gr).withProviderName("Google").build();
class de {
  /**
   * Create a new {@link module:@yext/components-geo~GeoBounds GeoBounds} with minimal area that
   * contains all the given coordinates
   * @param {module:@yext/components-geo~Coordinate[]} coordinates
   * @returns {module:@yext/components-geo~GeoBounds}
   */
  static fit(e) {
    const t = e.map((a) => a.latitude), r = Math.max(...t), s = Math.min(...t), i = e.map((a) => a.normalLon).sort((a, d) => a - d), c = i.map((a, d) => ({ distance: (d < i.length - 1 ? i[d + 1] : i[0] + 360) - a, index: d })).reduce((a, d) => d.distance > a.distance ? d : a).index, u = i[c], p = i[(c + 1) % i.length];
    return new this(new S(s, p), new S(r, u));
  }
  /**
   * @param {module:@yext/components-geo~Coordinate} sw Southwest coordinate
   * @param {module:@yext/components-geo~Coordinate} ne Northeast coordinate
   */
  constructor(e, t) {
    this._ne = new S(t), this._sw = new S(e);
  }
  /**
   * Northeast coordinate
   * @type {module:@yext/components-geo~Coordinate}
   */
  get ne() {
    return this._ne;
  }
  /**
   * Southwest coordinate
   * @type {module:@yext/components-geo~Coordinate}
   */
  get sw() {
    return this._sw;
  }
  set ne(e) {
    this._ne = new S(e);
  }
  set sw(e) {
    this._sw = new S(e);
  }
  /**
   * Whether the coordinate lies within the region defined by the bounds.
   * {@link module:@yext/components-geo~Coordinate#normalLon Normalized longitudes} are used for the
   * bounds and the coordinate.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   * @returns {boolean}
   */
  contains(e) {
    const t = this._sw.latitude <= e.latitude && e.latitude <= this._ne.latitude, r = this._ne.longitude - this._sw.longitude >= 360, s = this._sw.normalLon <= this._ne.normalLon ? this._sw.normalLon <= e.normalLon && e.normalLon <= this._ne.normalLon : this._sw.normalLon <= e.normalLon || e.normalLon <= this._ne.normalLon;
    return t && (r || s);
  }
  /**
   * Extend the bounds if necessary so that the coordinate is contained by them.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   */
  extend(e) {
    if (this._ne.latitude = Math.max(this._ne.latitude, e.latitude), this._sw.latitude = Math.min(this._sw.latitude, e.latitude), !this.contains(e)) {
      const t = ((e.longitude - this._ne.longitude) % 360 + 360) % 360, r = ((this._sw.longitude - e.longitude) % 360 + 360) % 360;
      t < r ? this._ne.longitude += t : this._sw.longitude -= r;
    }
  }
  /**
   * Calculate the center of the bounds using the given projection.
   * To find the visual center on a Mercator map, use Projection.MERCATOR.
   * To find the center for geolocation or geosearch purposes, use Projection.SPHERICAL.
   * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL]
   * @returns {module:@yext/components-geo~Coordinate}
   */
  getCenter(e = Q.SPHERICAL) {
    const t = new S(this._ne.latitude, this._sw.longitude), r = this._sw.distanceTo(t, O.DEGREE, e), s = (t.longitude + this._ne.longitude) / 2 + (this._ne.longitude < t.longitude ? 180 : 0);
    return t.add(-r / 2, 0, O.DEGREE, e), t.longitude = s, t;
  }
}
class Wr {
  constructor() {
    this._anchorX = 0.5, this._anchorY = 1, this._height = 39, this._icon = "default", this._srText = "map pin", this._width = 33, this._zIndex = 0, this._class = "", this._element = null;
  }
  /**
   * @returns {number} The point in the pin that should be positioned over the coordinate, from 0
   *   (left edge) to 1 (right edge)
   */
  getAnchorX() {
    return this._anchorX;
  }
  /**
   * @returns {number} The point in the pin that should be positioned over the coordinate, from 0
   *   (top edge) to 1 (bottom edge)
   */
  getAnchorY() {
    return this._anchorY;
  }
  /**
   * {@link module:@yext/components-maps~HTMLProviderPin HTMLProviderPins} only
   * @returns {string} The class of the wrapper element for an HTML pin
   */
  getClass() {
    return this._class;
  }
  /**
   * {@link module:@yext/components-maps~HTMLProviderPin HTMLProviderPins} only
   * @returns {string} The HTML pin element
   */
  getElement() {
    return this._element;
  }
  /**
   * @returns {number} The pixel height of the pin
   */
  getHeight() {
    return this._height;
  }
  /**
   * This returns a string key that can be used with {@link module:@yext/components-maps~MapPin#getIcon MapPin#getIcon}
   * to get the icon image for a pin.
   * @returns {string} The unique name of the icon
   */
  getIcon() {
    return this._icon;
  }
  /**
   * @returns {string} The text that a screen reader reads when focused on the pin
   */
  getSRText() {
    return this._srText;
  }
  /**
   * @returns {number} The pixel width of the pin
   */
  getWidth() {
    return this._width;
  }
  /**
   * @returns {number} The z-index of the pin
   */
  getZIndex() {
    return this._zIndex;
  }
  /**
   * @param {number} anchorX
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getAnchorX
   */
  setAnchorX(e) {
    return this._anchorX = e, this;
  }
  /**
   * @param {number} anchorY
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getAnchorY
   */
  setAnchorY(e) {
    return this._anchorY = e, this;
  }
  /**
   * @param {string} className
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getClass
   */
  setClass(e) {
    return this._class = e, this;
  }
  /**
   * @param {HTMLElement} element
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getElement
   */
  setElement(e) {
    return this._element = e, this;
  }
  /**
   * @param {number} height
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getHeight
   */
  setHeight(e) {
    return this._height = e, this;
  }
  /**
   * @param {string} icon
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getIcon
   */
  setIcon(e) {
    return this._icon = e, this;
  }
  /**
   * @param {string} srText
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getSRText
   */
  setSRText(e) {
    return this._srText = e, this;
  }
  /**
   * @param {number} width
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getWidth
   */
  setWidth(e) {
    return this._width = e, this;
  }
  /**
   * @param {number} zIndex
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getZIndex
   */
  setZIndex(e) {
    return this._zIndex = e, this;
  }
}
class lt {
  /**
   * Initialize with default options
   */
  constructor() {
    this.coordinate = new S(0, 0), this.hideOffscreen = !1, this.icons = {}, this.propertiesForStatus = (e) => new Wr(), this.provider = null, this.type = "";
  }
  /**
   * @param {Object} coordinate Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withCoordinate(e) {
    return this.coordinate = new S(e), this;
  }
  /**
   * @param {boolean} hideOffscreen If true, the pin will only be rendered if it's in the visible
   *   portion of the map to improve performance
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withHideOffscreen(e) {
    return this.hideOffscreen = e, this;
  }
  /**
   * @param {string} key The unique name for the icon, used in {@link module:@yext/components-maps~PinProperties#getIcon PinProperties#getIcon}
   *   and {@link module:@yext/components-maps~PinProperties#setIcon PinProperties#setIcon}
   * @param {string} icon The URL or data URI of the icon image
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withIcon(e, t) {
    return this.icons[e] = t, this;
  }
  /**
   * @param {module:@yext/components-maps~PinPropertiesForStatus} propertiesForStatus
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withPropertiesForStatus(e) {
    return z(e, V.FUNCTION), this.propertiesForStatus = e, this;
  }
  /**
   * @param {module:@yext/components-maps~MapProvider} provider
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withProvider(e) {
    return W(e, ge), this.provider = e, this;
  }
  /**
   * @param {string} type A string describing the type of the pin
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withType(e) {
    return this.type = e, this;
  }
  /**
   * @returns {module:@yext/components-maps~MapPin}
   */
  build() {
    return new zr(this);
  }
}
class zr {
  /**
   * @param {module:@yext/components-maps~MapPinOptions} options
   */
  constructor(e) {
    if (W(e, lt), W(e.provider, ge), !e.provider.loaded)
      throw new Error(`MapProvider '${e.provider.getProviderName()}' is not loaded. The MapProvider must be loaded before calling MapPin constructor.`);
    this._coordinate = e.coordinate, this._hideOffscreen = e.hideOffscreen, this._icons = { ...e.icons }, this._propertiesForStatus = e.propertiesForStatus, this._type = e.type, this._clickHandler = () => {
    }, this._focusHandler = (t) => this._hoverHandler(t), this._hoverHandler = (t) => {
    }, this._hidden = !1, this._cancelHiddenUpdater = () => {
    }, this._map = null, this._pin = new sn(e.provider).withIcons({ ...this._icons }).withClickHandler(() => this._clickHandler()).withFocusHandler((t) => this._focusHandler(t)).withHoverHandler((t) => this._hoverHandler(t)).build(), this._pin.setCoordinate(e.coordinate), this._status = {}, this.setStatus(this._status);
  }
  /**
   * @returns {module:@yext/components-tsx-geo~Coordinate} The coordinate of the pin
   */
  getCoordinate() {
    return this._coordinate;
  }
  /**
   * Get the icon for a string key, such as 'default', 'hovered', or 'selected'
   * @param {string} key The unique name of the icon
   * @returns {string} The URL or data URI of the icon image
   * @see module:@yext/components-maps~MapPinOptions#withIcon
   */
  getIcon(e) {
    return this._icons[e];
  }
  /**
   * @returns {module:@yext/components-maps~Map} The map that the pin is currently on, or null if
   * not on a map
   */
  getMap() {
    return this._map;
  }
  /**
   * Intended for internal use only
   * @returns {module:@yext/components-maps~ProviderPin} The pin's {@link module:@yext/components-maps~ProviderPin ProviderPin}
   *   instance
   */
  getProviderPin() {
    return this._pin;
  }
  /**
   * @returns {string} The string describing the type of pin
   */
  getType() {
    return this._type;
  }
  /**
   * Remove this pin from its current map, if on one.
   */
  remove() {
    this.setMap(null);
  }
  /**
   * Set a handler function for when the pin is clicked, replacing any previously set click handler.
   * @param {module:@yext/components-maps~PinClickHandler} clickHandler
   */
  setClickHandler(e) {
    z(e, V.FUNCTION), this._clickHandler = e;
  }
  /**
   * @param {Object} coordinate Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   */
  setCoordinate(e) {
    this._coordinate = new S(e), this._pin.setCoordinate(this._coordinate), this._hideOffscreen && this._hideIfOffscreen();
  }
  /**
   * Set a handler function for when the pin is (un)focused, replacing any previously set focus handler.
   * @param {module:@yext/components-maps~PinFocusHandler} focusHandler
   */
  setFocusHandler(e) {
    z(e, V.FUNCTION), this._focusHandler = e;
  }
  /**
   * Set a handler function for when the pin is (un)hovered, replacing any previously set hover handler.
   * @param {module:@yext/components-maps~PinHoverHandler} hoverHandler
   */
  setHoverHandler(e) {
    z(e, V.FUNCTION), this._hoverHandler = e;
  }
  /**
   * Add the pin to a map, removing it from its current map if on one.
   * @param {?Map} map
   */
  setMap(e) {
    if (e != this._map && (e !== null && W(e, cn), this._pin.setMap(e, this._hidden ? null : this._map), this._map = e, this._hidden = !1, this._cancelHiddenUpdater(), e && this._hideOffscreen)) {
      let t = !1;
      const r = new Promise((s) => {
        this._cancelHiddenUpdater = () => {
          t = !0, s();
        };
      });
      (async () => {
        for (; !t; )
          this._hideIfOffscreen(), await Promise.race([r, e.moving()]), await Promise.race([r, e.idle()]);
      })();
    }
  }
  /**
   * Assign all properties in an object to the pin's status.
   * Example: if the pin's status is { a: true, b: true }, passing in { a: false, c: true } will
   * change the pin's status to { a: false, b: true, c: true }
   * @param {Object} status
   */
  setStatus(e) {
    Object.assign(this._status, e), this._pin.setProperties(this._propertiesForStatus(this._status));
  }
  /**
   * Add or remove the pin from the map based on whether its coordinate is within the current bounds
   * @protected
   */
  _hideIfOffscreen() {
    if (this._map) {
      const e = this._map.getBounds().contains(this._coordinate);
      this._hidden && e ? this._pin.setMap(this._map, null) : !this._hidden && !e && this._pin.setMap(null, this._map), this._hidden = !e;
    }
  }
}
const le = 0.98;
function Be(n, e) {
  return Math.max(typeof n == V.FUNCTION ? n() : n || 0, 0) / e;
}
class an {
  /**
   * Initialize with default options
   */
  constructor() {
    this.controlEnabled = !0, this.defaultCenter = new S(39.83, -98.58), this.defaultZoom = 4, this.legendPins = [], this.padding = { bottom: () => 50, left: () => 50, right: () => 50, top: () => 50 }, this.panHandler = (e, t) => {
    }, this.panStartHandler = (e) => {
    }, this.provider = null, this.providerOptions = {}, this.singlePinZoom = 14, this.wrapper = null;
  }
  /**
   * @param {boolean} controlEnabled Whether the user can move and zoom the map
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withControlEnabled(e) {
    return this.controlEnabled = e, this;
  }
  /**
   * @param {module:@yext/components-tsx-geo~Coordinate} defaultCenter The center on initial load and
   *   when calling {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates} with an empty array
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withDefaultCenter(e) {
    return this.defaultCenter = new S(e), this;
  }
  /**
   * @param {number} defaultZoom The zoom on initial load and when calling {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}
   *   with an empty array
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withDefaultZoom(e) {
    return this.defaultZoom = e, this;
  }
  /**
   * @todo GENERATOR TODO Map legend not yet implemented
   * @param {module:@yext/components-maps~MapPin[]} legendPins Pins used to construct the map legend
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withLegendPins(e) {
    return this.legendPins = Array.from(e), this;
  }
  /**
   * Padding is used by {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}.
   * Padding can either be constant values or funtions that return a padding value.
   * See {@link module:@yext/components-maps~Map#setPadding Map#setPadding} for more information.
   * @param {Object} padding
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.bottom Minimum number of
   *   pixels between the map's bottom edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.left Minimum number of
   *   pixels between the map's left edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.right Minimum number of
   *   pixels between the map's right edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.top Minimum number of
   *   pixels between the map's top edge and a pin
   * @returns {module:@yext/components-maps~MapOptions}
   * @see module:@yext/components-maps~Map#setPadding
   */
  withPadding(e) {
    return this.padding = e, this;
  }
  /**
   * @param {module:@yext/components-maps~PanHandler} panHandler
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withPanHandler(e) {
    return z(e, V.FUNCTION), this.panHandler = e, this;
  }
  /**
   * @param {module:@yext/components-maps~PanStartHandler} panStartHandler
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withPanStartHandler(e) {
    return z(e, V.FUNCTION), this.panStartHandler = e, this;
  }
  /**
   * The {@link module:@yext/components-maps~MapProvider MapProvider} must be loaded before
   * constructing the {@link module:@yext/components-maps~Map Map}.
   * @param {module:@yext/components-maps~MapProvider} provider
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withProvider(e) {
    return W(e, ge), this.provider = e, this;
  }
  /**
   * @param {Object} providerOptions A free-form object used to set any additional provider-specific
   *   options in the {@link module:@yext/components-maps~ProviderMap ProviderMap}
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withProviderOptions(e) {
    return this.providerOptions = e, this;
  }
  /**
   * @param {number} singlePinZoom The zoom when calling {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}
   *   with an array containing one coordinate
   * @returns {MapOptions}
   */
  withSinglePinZoom(e) {
    return this.singlePinZoom = e, this;
  }
  /**
   * @param {HTMLElement} wrapper The wrapper element that the map will be inserted into. The
   *   existing contents of the element will be removed.
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withWrapper(e) {
    return W(e, HTMLElement), this.wrapper = e, this;
  }
  /**
   * @returns {module:@yext/components-maps~Map}
   */
  build() {
    return new cn(this);
  }
}
let cn = class {
  /**
   * The {@link module:@yext/components-maps~MapProvider MapProvider} for the map must be loaded
   * before calling this constructor.
   * @param {module:@yext/components-maps~MapOptions} options
   */
  constructor(e) {
    if (W(e, an), W(e.provider, ge), W(e.wrapper, HTMLElement), !e.provider.loaded)
      throw new Error(`MapProvider '${e.provider.getProviderName()}' is not loaded. The MapProvider must be loaded before calling Map constructor.`);
    for (this._defaultCenter = e.defaultCenter, this._defaultZoom = e.defaultZoom, this._legendPins = e.legendPins, this._provider = e.provider, this._singlePinZoom = e.singlePinZoom, this._wrapper = e.wrapper, this._padding = {}, this.setPadding(e.padding), this._cachedBounds = null, this._resolveIdle = () => {
    }, this._resolveMoving = () => {
    }, this._idlePromise = Promise.resolve(), this._setIdle(), this.setPanHandler(e.panHandler), this.setPanStartHandler(e.panStartHandler); this._wrapper.firstChild; )
      this._wrapper.removeChild(this._wrapper.lastChild);
    this._panHandlerRunning = !1, this._panStartHandlerRunning = !1, this._map = new rn(e.provider, this._wrapper).withControlEnabled(e.controlEnabled).withPanHandler(() => this.panHandler()).withPanStartHandler(() => this.panStartHandler()).withProviderOptions(e.providerOptions).build(), this.setZoomCenter(this._defaultZoom, this._defaultCenter), this._currentBounds = this.getBounds();
  }
  /**
   * Set the map bounds so that all the given coordinates are within the {@link module:@yext/components-maps~MapOptions#withPadding padded}
   * view.
   * @param {module:@yext/components-tsx-geo~Coordinate[]} coordinates
   * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
   * @param {number} [maxZoom=singlePinZoom] The max zoom level after fitting. Uses {@link module:@yext/components-maps~MapOptions#withSinglePinZoom singlePinZoom}
   *   by default.
   */
  fitCoordinates(e, t = !1, r = this._singlePinZoom) {
    e.length ? this.setBounds(de.fit(e), t, this._padding, r) : this.setZoomCenter(this._defaultZoom, this._defaultCenter, t);
  }
  /**
   * Get the current visible region of the map. If the map is zoomed out to show multiple copies of
   * the world, the longitude bounds will be outside [-180, 180) but the center will always be
   * within [-180, 180).
   * @returns {module:@yext/components-tsx-geo~GeoBounds}
   */
  getBounds() {
    if (!this._cachedBounds) {
      const e = this._wrapper.offsetHeight, t = this._wrapper.offsetWidth, r = this.getZoom(), s = this.getCenter(), i = 360 / Math.pow(2, r + 8), c = t * i, u = e * i;
      this._cachedBounds = new de(s, s), this._cachedBounds.ne.add(u / 2, c / 2, O.DEGREE, Q.MERCATOR), this._cachedBounds.sw.add(-u / 2, -c / 2, O.DEGREE, Q.MERCATOR), this.moving().then(() => this._cachedBounds = null);
    }
    return new de(this._cachedBounds.sw, this._cachedBounds.ne);
  }
  /**
   * @returns {module:@yext/components-tsx-geo~Coordinate} The center of the current visible region of
   *   the map
   */
  getCenter() {
    return this._map.getCenter();
  }
  /**
   * Intended for internal use only
   * @returns {module:@yext/components-maps~ProviderMap} The map's {@link module:@yext/components-maps~ProviderMap ProviderMap}
   *   instance
   */
  getProviderMap() {
    return this._map;
  }
  /**
   * To standardize zoom for all providers, zoom level is calculated with this formula:
   * zoom = log2(pixel width of equator) - 8.
   * At zoom = 0, the entire world is 256 pixels wide.
   * At zoom = 1, the entire world is 512 pixels wide.
   * Zoom 2  1024 pixels, zoom 3  2056 pixels, etc.
   * Negative and non-integer zoom levels are valid and follow the formula.
   * @returns {number} The current zoom level of the map
   */
  getZoom() {
    return this._map.getZoom();
  }
  /**
   * Returns when the map is not moving.
   * Use map.idle().then(callback) to run callback immediately if the map is currently idle or once
   * the map becomes idle if it's not.
   */
  async idle() {
    await this._idlePromise;
  }
  /**
   * Returns when the map is moving.
   * Use map.moving().then(callback) to run callback immediately if the map is currently moving or
   * once the map starts moving if it's not.
   */
  async moving() {
    await this._movingPromise;
  }
  /**
   * @returns {module:@yext/components-maps~MapPinOptions} A {@link module:@yext/components-maps~MapPinOptions MapPinOptions}
   *   instance with the same provider as this map
   */
  newPinOptions() {
    return new lt().withProvider(this._provider);
  }
  /**
   * Called when the map has finished moving, at most once per animation frame.
   * Passes the current and previous bounds to the custom pan handler given by {@link module:@yext/components-maps~MapOptions#withPanHandler MapOptions#withPanHandler}
   */
  panHandler() {
    this._panHandlerRunning || (this._panHandlerRunning = !0, requestAnimationFrame(() => {
      const e = this._currentBounds;
      this._currentBounds = this.getBounds(), this._panHandler(e, new de(
        new S(this._currentBounds.sw),
        new S(this._currentBounds.ne)
      )), this._panHandlerRunning = !1;
    }), this._setIdle());
  }
  /**
   * Called when the map has started moving, at most once per animation frame.
   * Passes the current bounds to the custom pan handler given by {@link module:@yext/components-maps~MapOptions#withPanStartHandler MapOptions#withPanStartHandler}
   */
  panStartHandler() {
    this._panStartHandlerRunning || (this._panStartHandlerRunning = !0, requestAnimationFrame(() => {
      this._panStartHandler(new de(
        new S(this._currentBounds.sw),
        new S(this._currentBounds.ne)
      )), this._panStartHandlerRunning = !1;
    }), this._setMoving());
  }
  /**
   * @param {Object} bounds
   * @param {Object} bounds.ne The northeast corner of the bounds -- must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {Object} bounds.sw The southwest corner of the bounds -- must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
   * @param {Object} [padding={}]
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.bottom Minimum number of
   *   pixels between the map's bottom edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.left Minimum number of
   *   pixels between the map's left edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.right Minimum number of
   *   pixels between the map's right edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.top Minimum number of
   *   pixels between the map's top edge and a pin
   * @param {number} [maxZoom=Infinity]
   */
  setBounds({ ne: e, sw: t }, r = !1, s = {}, i = 1 / 0) {
    const c = this._wrapper.offsetHeight, u = this._wrapper.offsetWidth;
    if (!c || !u)
      return;
    let p = Be(s.bottom, c), a = Be(s.left, u), d = Be(s.right, u), f = Be(s.top, c), _ = a + d, y = p + f;
    _ > le && (a *= le / _, d *= le / _, _ = le), y > le && (p *= le / y, f *= le / y, y = le);
    const v = c * (1 - y), E = u * (1 - _), A = new de(t, e), U = new S(A.ne.latitude, A.sw.longitude), T = A.sw.distanceTo(U, O.DEGREE, Q.MERCATOR), q = (A.ne.longitude - U.longitude + 360) % 360;
    let D = Math.max(T, q * v / E) / (1 - y), $ = Math.max(q, T * E / v) / (1 - _), K = Math.log2(u * 360 / $) - 8;
    K > i && (K = i, $ = u * 360 / 2 ** (K + 8), D = $ * c / u);
    const ne = A.getCenter(Q.MERCATOR), G = (f - p) / 2 * D, x = (d - a) / 2 * $;
    ne.add(G, x, O.DEGREE, Q.MERCATOR), this.setZoomCenter(K, ne, r);
  }
  /**
   * @param {Object} coordinate Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} [animated=false] Whether to transition smoothly to the new center
   */
  setCenter(e, t = !1) {
    this._map.setCenter(new S(e), t);
  }
  /**
   * Padding is used by {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}.
   * Padding can either be constant values or funtions that return a padding value.
   * Constant values are good if the map should always have the same padding on every breakpoint.
   * Functions are useful if the map should have different padding at different breakpoints/layouts.
   * The function can check window.innerWidth or any other condition before returning a number.
   * @param {Object} padding
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.bottom Minimum number of
   *   pixels between the map's bottom edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.left Minimum number of
   *   pixels between the map's left edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.right Minimum number of
   *   pixels between the map's right edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.top Minimum number of
   *   pixels between the map's top edge and a pin
   * @returns {module:@yext/components-maps~Map}
   */
  setPadding({
    bottom: e = this._padding.bottom,
    left: t = this._padding.left,
    right: r = this._padding.right,
    top: s = this._padding.top
  }) {
    return this._padding = { bottom: e, left: t, right: r, top: s }, this;
  }
  /**
   * @param {module:@yext/components-maps~Map~panHandler} panHandler
   */
  setPanHandler(e) {
    z(e, V.FUNCTION), this._panHandler = e;
  }
  /**
   * @param {module:@yext/components-maps~Map~panStartHandler} panStartHandler
   */
  setPanStartHandler(e) {
    z(e, V.FUNCTION), this._panStartHandler = e;
  }
  /**
   * @param {number} zoom
   * @param {boolean} [animated=false] Whether to transition smoothly to the new zoom
   * @see module:@yext/components-maps~Map#getZoom
   */
  setZoom(e, t = !1) {
    this._map.setZoom(e, t);
  }
  /**
   * @param {number} zoom
   * @param {Object} center Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
   * @see module:@yext/components-maps~Map#setZoom
   * @see module:@yext/components-maps~Map#setCenter
   */
  setZoomCenter(e, t, r = !1) {
    this._map.setZoomCenter(e, t, r);
  }
  /**
   * Set the map state to idle
   * @protected
   */
  _setIdle() {
    this._resolveMoving(), this._movingPromise = new Promise((e) => this._resolveMoving = e), this._resolveIdle();
  }
  /**
   * Set the map state to moving
   * @protected
   */
  _setMoving() {
    this._resolveIdle(), this._idlePromise = new Promise((e) => this._resolveIdle = e), this._resolveMoving();
  }
};
const je = ot(null);
function Di() {
  const n = we(je);
  if (!n || n.map === void 0)
    throw new Error("Attempted to call useMapContext() outside of <Map>.");
  return n.map;
}
const ln = ({
  apiKey: n,
  bounds: e,
  children: t,
  className: r,
  clientKey: s,
  controls: i,
  defaultCenter: c,
  defaultZoom: u,
  mapRef: p,
  padding: a,
  panStartHandler: d,
  panHandler: f,
  provider: _,
  providerOptions: y,
  singleZoom: v
}) => {
  const E = at(null), [A, U] = ie(c), [T, q] = ie(!1), [D, $] = ie(), [K, ne] = ie(u), G = (x, te) => {
    f(x, te), U(te.getCenter());
  };
  return ae(() => {
    !T || !D || ne(D.getZoom());
  }, [A]), ae(() => {
    if (!e || !T || !D)
      return;
    const x = e.map((te) => new S(te));
    D.fitCoordinates(x);
  }, [JSON.stringify(e), D]), ae(() => {
    if (!T || D)
      return;
    const x = new an().withControlEnabled(i).withDefaultCenter(A).withDefaultZoom(K).withPadding(a).withPanHandler(G).withPanStartHandler(d).withProvider(_).withProviderOptions(y).withSinglePinZoom(v).withWrapper(E.current).build();
    $(x), p && (p.current = x);
  }, [T]), ae(() => {
    if (T || D || !E.current)
      return;
    const x = _.getProviderName() === "Google" && s;
    _.load(n, x ? { client: s } : {}).then(() => q(!0));
  }, []), /* @__PURE__ */ R.jsx(
    "div",
    {
      className: en(
        {
          "is-loaded": T
        },
        r
      ),
      id: "map",
      ref: E,
      "data-testid": "map",
      children: D && /* @__PURE__ */ R.jsx(je.Provider, { value: { map: D, provider: _ }, children: t })
    }
  );
};
ln.defaultProps = {
  controls: !0,
  defaultCenter: { latitude: 39.83, longitude: -98.58 },
  defaultZoom: 4,
  padding: { bottom: 50, left: 50, right: 50, top: 50 },
  panHandler: () => null,
  panStartHandler: () => null,
  provider: on,
  providerOptions: {},
  singleZoom: 14
};
const Yr = ({ count: n }) => /* @__PURE__ */ R.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "22",
    height: "22",
    viewBox: "0 0 22 22",
    children: /* @__PURE__ */ R.jsxs("g", { fill: "none", fillRule: "evenodd", children: [
      /* @__PURE__ */ R.jsx(
        "circle",
        {
          fill: "red",
          fillRule: "nonzero",
          stroke: "white",
          cx: "11",
          cy: "11",
          r: "11"
        }
      ),
      /* @__PURE__ */ R.jsx(
        "text",
        {
          fill: "white",
          fontFamily: "Arial-BoldMT,Arial",
          fontSize: "12",
          fontWeight: "bold",
          children: /* @__PURE__ */ R.jsx("tspan", { x: "50%", y: "15", textAnchor: "middle", children: n })
        }
      )
    ] })
  }
), ut = ot(
  null
);
function Bi() {
  const n = we(ut);
  if (!n)
    throw new Error(
      "Attempted to call useClustererContext() outside of <Clusterer>."
    );
  return n;
}
const Ni = ({
  clusterRadius: n = 50,
  children: e,
  ClusterTemplate: t = Yr
}) => {
  const { map: r } = we(je), [s, i] = ie([]), [c, u] = ie(), [p, a] = ie([]), [d, f] = ie([]);
  return ae(() => {
    u(qr(s, r, n));
  }, [s, r.getZoom()]), ae(() => {
    f(() => []), a(() => []), (c == null ? void 0 : c.length) !== 0 && (c == null || c.forEach((_) => {
      if (_.length === 1) {
        _[0].pin.setMap(r);
        return;
      }
      if (_.length > 1) {
        const y = de.fit(
          _.map((E) => E.pin.getCoordinate())
        ).getCenter(Q.MERCATOR), v = `cluster-{${y._lat},${y._lon}}`;
        _.forEach((E) => E.pin.setMap(null)), a((E) => [...E, v]), f((E) => [
          ...E,
          /* @__PURE__ */ R.jsx(
            dt,
            {
              coordinate: y,
              id: v,
              onClick: () => r.fitCoordinates(
                _.map((A) => A.pin.getCoordinate()),
                !0,
                1 / 0
              ),
              children: /* @__PURE__ */ R.jsx(t, { count: _.length })
            },
            v
          )
        ]);
      }
    }));
  }, [c]), /* @__PURE__ */ R.jsx(
    ut.Provider,
    {
      value: {
        clusters: c ?? [],
        clusterIds: p,
        setPinStore: i
      },
      children: /* @__PURE__ */ R.jsxs(R.Fragment, { children: [
        d.map((_, y) => /* @__PURE__ */ R.jsx($n, { children: _ }, y)),
        e
      ] })
    }
  );
}, qr = (n, e, t) => {
  const r = t * Math.PI / 2 ** (e.getZoom() + 7), s = n.map((u, p) => [p]), i = [];
  n.forEach((u, p) => {
    for (let a = p; a < n.length; a++)
      a != p && new S(u.pin.getCoordinate()).distanceTo(
        new S(n[a].pin.getCoordinate()),
        O.RADIAN,
        Q.MERCATOR
      ) <= r && (s[p].push(a), s[a].push(p));
  });
  let c = 1;
  for (; c; ) {
    c = 0;
    let u;
    if (s.forEach((d, f) => {
      d.length > c && (c = d.length, u = f);
    }), !c)
      break;
    const p = s[u ?? 0], a = [];
    s[u ?? 0] = [];
    for (const d of p) {
      const f = s[d];
      a.push(n[d]), s[d] = [], f.forEach(
        (_) => s[_].splice(
          s[_].indexOf(d),
          1
        )
      );
    }
    i.push(a);
  }
  return i;
}, Kr = /* @__PURE__ */ R.jsx(
  "svg",
  {
    width: "30",
    height: "38",
    viewBox: "0 0 30 38",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ R.jsx(
      "path",
      {
        d: "M30 15.0882C30 23.4212 23.3333 30.7353 15 38C7.22222 31.2941 0 23.4212 0 15.0882C0 6.75523 6.71573 0 15 0C23.2843 0 30 6.75523 30 15.0882Z",
        fill: "red"
      }
    )
  }
), dt = ({
  children: n,
  coordinate: e,
  hideOffscreen: t,
  id: r,
  icon: s,
  onClick: i,
  onFocus: c,
  onHover: u,
  zIndex: p
}) => {
  const { map: a, provider: d } = we(je), f = we(ut), _ = Gn(() => new lt().withCoordinate(e).withHideOffscreen(t).withProvider(d).build(), []);
  ae(() => {
    if (p !== 0 && !p)
      return;
    const v = _.getProviderPin().getWrapperElement();
    v && (v.style.zIndex = p.toString());
  }, [p]), ae(() => {
    _.setMap(a), _.setClickHandler(() => i(r)), _.setFocusHandler((E) => c(E, r)), _.setHoverHandler((E) => u(E, r));
    const v = f == null ? void 0 : f.clusterIds.includes(r);
    return f && !v && f.setPinStore((E) => [
      ...E,
      {
        pin: _,
        id: r
      }
    ]), () => {
      _.setMap(null), f && f.setPinStore(
        (E) => E.filter((A) => A.id !== r)
      );
    };
  }, []);
  const y = n || s;
  if (y) {
    const v = _.getProviderPin().getPinElement();
    return Object.assign(v.style, {
      height: "auto",
      width: "auto"
    }), Zn(y, v);
  }
  return null;
};
dt.defaultProps = {
  hideOffscreen: !1,
  icon: Kr,
  onClick: () => null,
  onHover: () => null,
  onFocus: () => null
};
const Xr = ({
  children: n,
  coordinate: e,
  linkSameTab: t,
  pinUrl: r,
  onClick: s = () => null,
  onHover: i = () => null,
  onFocus: c = () => null,
  ...u
}) => /* @__PURE__ */ R.jsx(ln, { bounds: [e], ...u, children: /* @__PURE__ */ R.jsx(
  dt,
  {
    coordinate: e,
    id: "location-map-marker",
    onClick: s,
    onHover: i,
    onFocus: c,
    children: r ? /* @__PURE__ */ R.jsx(Dr, { href: r, target: t ? "_self" : "_blank", children: n }) : n || void 0
  }
) });
Xr.defaultProps = {
  controls: !0,
  panHandler: () => null,
  provider: on,
  singleZoom: 16
};
const it = Math.log2(1.6745627884839434), Jr = 4, Qr = 19, st = "js-baidu-neg-lng-fix";
let un;
const ei = new Promise((n) => un = n), ti = "https://api.map.baidu.com/geoconv/v1/";
let Ie = [];
const ni = "gcj02ToBD09Callback_b872c21c";
let ri = 0, Gt;
async function dn(n) {
  return await new Promise((e, t) => {
    Ie.push({ coordinates: n, resolve: e, reject: t }), Ie.length == 1 && (Gt = setTimeout(r, 100)), Ie.length > 40 && (clearTimeout(Gt), r());
    function r() {
      const s = Ie;
      Ie = [];
      const i = [].concat(...s.map((p) => p.coordinates)), c = ni + "_" + ri++, u = document.createElement("script");
      window[c] = (p) => {
        if (p.status) {
          const f = new Error(`Unable to convert coordinates to BD-09: Received status code ${p.status}${p.message ? ": " + p.message : ""}`);
          s.forEach((_) => _.reject(f));
        }
        const a = p.result.map((f) => new S(f.y, f.x));
        let d = 0;
        s.forEach((f) => {
          f.resolve(a.slice(d, d += f.coordinates.length));
        }), delete window[c], u.parentNode.removeChild(u);
      }, ei.then((p) => {
        const a = {
          ak: p,
          callback: c,
          coords: i.map((d) => `${d.longitude},${d.latitude}`).join(";"),
          from: 3,
          to: 5
        };
        u.src = ti + "?" + Object.entries(a).map(([d, f]) => d + "=" + f).join("&"), document.head.appendChild(u);
      });
    }
  });
}
class ii extends Ee {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(e) {
    super(e);
    const t = !!(window.MSInputMethodContext && document.documentMode);
    this._wrapper = e.wrapper, this.map = new BMap.Map(this._wrapper, {
      enableMapClick: e.controlEnabled,
      // A side effect of the negative pin longitude glitch is that pins don't render at higher zoom levels.
      // For IE, 15 and above is broken. For other browsers, 19 and above.
      maxZoom: t ? 14 : 18,
      ...e.providerOptions
    }), e.controlEnabled ? (this.map.enableScrollWheelZoom(), this.map.addControl(new BMap.NavigationControl({
      anchor: BMAP_ANCHOR_TOP_RIGHT,
      type: BMAP_NAVIGATION_CONTROL_ZOOM
    }))) : (this.map.disableDragging(), this.map.disableDoubleClickZoom(), this.map.disablePinchToZoom()), this.map.addEventListener("movestart", () => this._panStartHandler()), this.map.addEventListener("moveend", () => this._panHandler()), this.map.addEventListener("zoomstart", () => this._panStartHandler()), this.map.addEventListener("zoomend", () => {
      this._wrapper.dataset.baiduZoom = this.map.getZoom(), this._panHandler();
    }), this._centerReady = Promise.resolve();
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new S(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom() - it;
  }
  /**
   * @inheritdoc
   */
  setCenter(e, t) {
    this._centerReady = dn([e]).then(([r]) => {
      const s = new BMap.Point(r.longitude, r.latitude);
      this.map.panTo(s, { noAnimation: !t });
    });
  }
  /**
   * @inheritdoc
   */
  setZoom(e, t) {
    this._centerReady.then(() => {
      this.map.setViewport({
        center: this.map.getCenter(),
        zoom: Math.floor(e + it)
        // Baidu only allows integer zoom
      }, { enableAnimation: t });
    });
  }
}
class si extends He {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(e) {
    super(e), this._wrapper = null, this._zIndex = 0, this._wrapperClass = "", this._originalWrapperClass = "", this._element = this._pinEl, this._coordinateReady = Promise.resolve(), this._negativeLngFix = !1;
    const t = this;
    class r extends BMap.Marker {
      initialize(c) {
        return t._wrapper = super.initialize(c), t._wrapper && (t._wrapper.style.zIndex = t._zIndex, t._originalWrapperClass = t._wrapper.getAttribute("class"), t._wrapper.setAttribute("class", t._getClass()), t._wrapper.appendChild(t._element), t.addListeners()), t._wrapper;
      }
      draw() {
        if (t._wrapper) {
          const c = t._wrapper.style.zIndex;
          super.draw(), t._wrapper.style.height = "", t._wrapper.style.width = "", t._wrapper.style.pointerEvents = "none", t._wrapper.style.zIndex = c;
        } else
          super.draw();
      }
    }
    this.pin = new r(new BMap.Point(0, 0));
    const s = new BMap.Icon("data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", { height: 0, width: 0 });
    this.pin.setIcon(s), this.pin.setShadow(s);
  }
  /**
   * @inheritdoc
   */
  addListeners() {
    super.addListeners(), this._wrapper.addEventListener("touchend", () => this._clickHandler());
  }
  /**
   * @inheritdoc
   */
  setCoordinate(e) {
    this._coordinateReady = dn([e]).then(([t]) => {
      this._negativeLngFix = t.longitude < 0, this.pin.setPosition(new BMap.Point(t.longitude + (this._negativeLngFix ? 180 : 0), t.latitude)), this._wrapper && this._wrapper.classList[this._negativeLngFix ? "add" : "remove"](st);
    });
  }
  /**
   * @inheritdoc
   */
  setMap(e, t) {
    this._coordinateReady.then(() => {
      t && t.getProviderMap().map.removeOverlay(this.pin), e && e.getProviderMap().map.addOverlay(this.pin);
    });
  }
  /**
   * @inheritdoc
   */
  setProperties(e) {
    super.setProperties(e), this._wrapperClass = e.getClass(), this._element = e.getElement() || this._pinEl, this._zIndex = e.getZIndex(), this._wrapper && this._wrapper.setAttribute("class", this._getClass());
  }
  /**
   * Get the class attribute value for the pin element
   * @protected
   * @returns {string}
   */
  _getClass() {
    return `${this._originalWrapperClass} ${this._negativeLngFix ? st : ""} ${this._wrapperClass}`;
  }
}
const oi = "https://api.map.baidu.com/getscript";
function ai(n, e, t, {
  params: r = {},
  version: s = "3.0"
} = {}) {
  window.BMAP_PROTOCOL = "https", window.BMap_loadScriptTime = (/* @__PURE__ */ new Date()).getTime();
  const i = t, c = {
    ak: i,
    v: s,
    ...r
  };
  un(i);
  const u = document.createElement("script");
  u.src = oi + "?" + Object.entries(c).map(([d, f]) => d + "=" + f).join("&"), u.onload = () => n(), document.head.appendChild(u);
  let p = "";
  for (let d = Jr; d <= Qr; d++) {
    const f = 2 ** (d - it + 7);
    p += `[data-baidu-zoom="${d}"] .${st}{transform:translateX(-${f}px);}`;
  }
  const a = document.createElement("style");
  a.innerHTML = p, document.head.appendChild(a);
}
const Hi = new fe().withLoadFunction(ai).withMapClass(ii).withPinClass(si).withProviderName("Baidu").build();
let hn;
function ci() {
  class n extends Microsoft.Maps.CustomOverlay {
    constructor() {
      super({ beneathLabels: !1 }), this._container = document.createElement("div"), this._map = null, this._pins = /* @__PURE__ */ new Set(), this._viewChangeEventHandler = null, this._container.style.position = "absolute", this._container.style.left = "0", this._container.style.top = "0";
    }
    addPin(t) {
      this._pins.add(t), t._wrapper.style.position = "absolute", this._container.appendChild(t._wrapper), this._map && this.updatePinPosition(t);
    }
    onAdd() {
      this._map = this.getMap(), this.setHtmlElement(this._container);
    }
    onLoad() {
      this._viewChangeEventHandler = Microsoft.Maps.Events.addHandler(this._map, "viewchange", () => this.updatePinPositions()), this.updatePinPositions();
    }
    onRemove() {
      Microsoft.Maps.Events.removeHandler(this._viewChangeEventHandler), this._map = null;
    }
    removePin(t) {
      this._pins.delete(t), this._container.removeChild(t._wrapper);
    }
    updatePinPosition(t) {
      if (!this._map)
        return;
      const r = this._map.tryLocationToPixel(t._location, Microsoft.Maps.PixelReference.control);
      t._wrapper.style.left = r.x + "px", t._wrapper.style.top = r.y + "px";
    }
    updatePinPositions() {
      this._pins.forEach((t) => this.updatePinPosition(t));
    }
  }
  hn = n;
}
class li extends Ee {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(e) {
    super(e), this.wrapper = e.wrapper, this.map = new Microsoft.Maps.Map(this.wrapper, {
      disablePanning: !e.controlEnabled,
      disableZooming: !e.controlEnabled,
      showLocateMeButton: !1,
      showMapTypeSelector: !1,
      showScalebar: !1,
      showTrafficButton: !1,
      ...e.providerOptions
    }), this.pinOverlay = new hn(this.map), this.map.layers.insert(this.pinOverlay), Microsoft.Maps.Events.addHandler(this.map, "viewchangestart", () => this._panStartHandler()), Microsoft.Maps.Events.addHandler(this.map, "viewchangeend", () => this._panHandler());
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new S(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom();
  }
  /**
   * @inheritdoc
   */
  setCenter(e, t) {
    const r = new Microsoft.Maps.Location(e.latitude, e.longitude);
    this.map.setView({ center: r }), this.pinOverlay.updatePinPositions();
  }
  /**
   * @inheritdoc
   */
  setZoom(e, t) {
    this.map.setView({ zoom: Math.floor(e) }), this.pinOverlay.updatePinPositions();
  }
}
class ui extends He {
  /**
   * Bing pins need global callbacks to complete initialization.
   * This function provides a unique ID to include in the name of the callback.
   * @returns {number} An ID for the pin unique across all instances of {@link module:@yext/components-maps~BingPin BingPin}
   */
  static getId() {
    return this._pinId = (this._pinId || 0) + 1, this._pinId;
  }
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(e) {
    super(e), this._map = null, this._location = new Microsoft.Maps.Location(0, 0);
  }
  /**
   * @inheritdoc
   */
  setCoordinate(e) {
    this._location = new Microsoft.Maps.Location(e.latitude, e.longitude), this._map && this._map.getProviderMap().pinOverlay.updatePinPosition(this);
  }
  /**
   * @inheritdoc
   */
  setMap(e, t) {
    t && t.getProviderMap().pinOverlay.removePin(this), e && e.getProviderMap().pinOverlay.addPin(this), this._map = e;
  }
}
const Zt = "BingMapsCallback_593d7d33", di = "https://www.bing.com/api/maps/mapcontrol";
function hi(n, e, t, {
  params: r = {}
} = {}) {
  window[Zt] = () => {
    ci(), n();
  };
  const s = {
    callback: Zt,
    key: t,
    ...r
  };
  nn(di + "?" + Object.entries(s).map(([i, c]) => i + "=" + c).join("&"));
}
const ji = new fe().withLoadFunction(hi).withMapClass(li).withPinClass(ui).withProviderName("Bing").build();
class pi extends Ee {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(e) {
    if (super(e), this.map = new mapboxgl.Map({
      container: e.wrapper,
      interactive: e.controlEnabled,
      style: "mapbox://styles/mapbox/streets-v9",
      ...e.providerOptions
    }), e.controlEnabled) {
      const t = new mapboxgl.NavigationControl({ showCompass: !1 });
      this.map.addControl(t);
    }
    this.map.on("movestart", () => this._panStartHandler()), this.map.on("moveend", () => this._panHandler());
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new S(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom() + 1;
  }
  /**
   * @inheritdoc
   */
  setCenter(e, t) {
    const r = new mapboxgl.LngLat(e.longitude, e.latitude);
    this.map[t ? "panTo" : "setCenter"](r);
  }
  /**
   * @inheritdoc
   */
  setZoom(e, t) {
    this.map[t ? "zoomTo" : "setZoom"](e - 1);
  }
  /**
   * @inheritdoc
   */
  setZoomCenter(e, t, r) {
    const s = new mapboxgl.LngLat(t.longitude, t.latitude);
    this.map[r ? "easeTo" : "jumpTo"]({ center: s, zoom: e - 1 });
  }
}
class fi extends He {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(e) {
    super(e), this._wrapper.style.position = "relative", this.pin = new mapboxgl.Marker({
      anchor: "top-left",
      element: this._wrapper
    });
  }
  /**
   * @inheritdoc
   */
  setCoordinate(e) {
    this.pin.setLngLat(new mapboxgl.LngLat(e.longitude, e.latitude));
  }
  /**
   * @inheritdoc
   */
  setMap(e, t) {
    e ? this.pin.addTo(e.getProviderMap().map) : this.pin.remove();
  }
}
function gi(n, e, t, {
  version: r = "v1.13.0"
} = {}) {
  const s = `https://api.mapbox.com/mapbox-gl-js/${r}/mapbox-gl`, i = document.createElement("link");
  i.rel = "stylesheet", i.href = s + ".css";
  const c = document.createElement("script");
  c.src = s + ".js", c.onload = () => {
    mapboxgl.accessToken = t, n();
  }, document.head.appendChild(i), document.head.appendChild(c);
}
const Ui = new fe().withLoadFunction(gi).withMapClass(pi).withPinClass(fi).withProviderName("Mapbox").build();
let pn = class extends Ee {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(e) {
    super(e), this._initMap(e), e.controlEnabled && this.map.zoomControl.setPosition("topright"), this.map.on("movestart", () => this._panStartHandler()), this.map.on("moveend", () => this._panHandler());
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new S(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom();
  }
  /**
   * @inheritdoc
   */
  setCenter(e, t) {
    const r = new L.latLng(e.latitude, e.longitude);
    this.map.panTo(r, { animate: t });
  }
  /**
   * @inheritdoc
   */
  setZoom(e, t) {
    this.map.setZoom(e, { animate: t });
  }
  /**
   * @inheritdoc
   */
  setZoomCenter(e, t, r) {
    const s = new L.latLng(t.latitude, t.longitude);
    this.map.setView(s, e, { animate: r });
  }
  /**
   * Initialize the Leaflet map
   * @protected
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  _initMap(e) {
    this.map = new L.map(e.wrapper, {
      boxZoom: e.controlEnabled,
      doubleClickZoom: e.controlEnabled,
      dragging: e.controlEnabled,
      zoom: 0,
      zoomControl: e.controlEnabled,
      zoomSnap: 0,
      ...e.providerOptions
    });
    const t = e.providerOptions, r = t.tileLayerSrc || "https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}", s = t.tileLayerOptions || {
      attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery  <a href="https://www.mapbox.com/">Mapbox</a>',
      id: "mapbox/streets-v11"
    };
    s.accessToken = this.constructor.apiKey, L.tileLayer(r, s).addTo(this.map);
  }
}, mi = class extends ct {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(e) {
    super(e), this.pin = new L.marker(), this.pin.on("click", () => this._clickHandler()), this.pin.on("mouseover", () => this._hoverHandler(!0)), this.pin.on("mouseout", () => this._hoverHandler(!1));
  }
  /**
   * @inheritdoc
   */
  setCoordinate(e) {
    const t = new L.latLng(e.latitude, e.longitude);
    this.pin.setLatLng(t);
  }
  /**
   * @inheritdoc
   */
  setMap(e, t) {
    e ? this.pin.addTo(e.getProviderMap().map) : this.pin.remove();
  }
  /**
   * @inheritdoc
   */
  setProperties(e) {
    const t = e.getWidth(), r = e.getHeight(), s = e.getAnchorX(), i = e.getAnchorY();
    this.pin.setIcon(new L.icon({
      iconUrl: this._icons[e.getIcon()],
      iconSize: [t, r],
      iconAnchor: [s * t, i * r],
      className: e.getClass()
    })), this.pin.setZIndexOffset(e.getZIndex());
  }
};
function _i(n, e, t, {
  version: r = "1.7.1"
} = {}) {
  const s = `https://unpkg.com/leaflet@${r}/dist/leaflet`;
  pn.apiKey = t;
  const i = document.createElement("link");
  i.rel = "stylesheet", i.href = s + ".css";
  const c = document.createElement("script");
  c.src = s + ".js", c.onload = () => n(), document.head.appendChild(i), document.head.appendChild(c);
}
const fn = new fe().withLoadFunction(_i).withMapClass(pn).withPinClass(mi).withProviderName("Leaflet").build(), vi = fn.getMapClass(), wi = fn.getPinClass();
class yi extends vi {
  /**
   * @inheritdoc
   */
  _initMap(e) {
    this.map = L.mapquest.map(e.wrapper, {
      boxZoom: e.controlEnabled,
      center: new L.latLng(0, 0),
      doubleClickZoom: e.controlEnabled,
      dragging: e.controlEnabled,
      layers: L.mapquest.tileLayer("map"),
      zoom: 0,
      zoomControl: e.controlEnabled,
      zoomSnap: 0,
      ...e.providerOptions
    });
  }
}
class bi extends wi {
}
function Ci(n, e, t, {
  version: r = "v1.3.2"
} = {}) {
  const s = `https://api.mqcdn.com/sdk/mapquest-js/${r}/mapquest-maps`, i = document.createElement("link");
  i.rel = "stylesheet", i.href = s + ".css";
  const c = document.createElement("script");
  c.src = s + ".js", c.onload = () => {
    L.mapquest.key = t, n();
  }, document.head.appendChild(i), document.head.appendChild(c);
}
const Gi = new fe().withLoadFunction(Ci).withMapClass(yi).withPinClass(bi).withProviderName("MapQuest").build();
export {
  tr as Address,
  Pr as Analytics,
  qt as AnalyticsContext,
  xi as AnalyticsProvider,
  Ii as AnalyticsScopeProvider,
  Hi as BaiduMaps,
  ji as BingMaps,
  Ni as Clusterer,
  on as GoogleMaps,
  Oi as Image,
  he as ImageLayoutOption,
  fn as LeafletMaps,
  Dr as Link,
  Li as LinkType,
  qn as ListingPublisherOption,
  Xr as LocationMap,
  ln as Map,
  kt as MapProviderOption,
  Gi as MapQuestMaps,
  Ui as MapboxMaps,
  dt as Marker,
  Ri as getDirections,
  Ne as useAnalytics,
  Bi as useClusterContext,
  Si as useIdentify,
  Di as useMapContext,
  ki as usePageView,
  Xt as useScope,
  Mi as useTrack
};
