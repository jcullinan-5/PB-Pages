"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const resolve_1 = require("eslint-module-utils/resolve");
const typescript_estree_1 = require("@typescript-eslint/typescript-estree");
/**
 * This rule checks to make sure there are no duplicate identifiers exported from any files,
 * taking into account`export *` statements.
 */
const rule = {
    meta: {
        type: 'suggestion',
        messages: {
            duplicateIdentifier: `Duplicate exported identifier '{{ identifier }}'`
        },
        schema: []
    },
    create: createASTVisitor
};
exports.default = rule;
/**
 * Creates an AST visitor that is used to visit nodes in the typescript-eslint generated estree.
 * Handles ExportAllDeclarations and ExportNamedDeclarations, and keeps track of already exported
 * identifiers using a set.
 */
function createASTVisitor(context) {
    const exportedIdentifiers = new Set();
    /** Report to eslint that a duplicate export has been found. */
    function reportIfDuplicate(node, identifier, loc) {
        if (exportedIdentifiers.has(identifier)) {
            context.report(Object.assign({ messageId: 'duplicateIdentifier', data: { identifier }, node }, (loc && { loc })));
        }
        else {
            exportedIdentifiers.add(identifier);
        }
    }
    /**
     * Handles named exports, including less common export syntax like destructured assignments.
     *
     * @example
     * ```ts
     * // typical named export
     * export { pisatchio } from 'cookies';
     *
     * // destructured assignment
     * export const { walnut: pisatchio, ...otherNuts } = nuts;
     * ```
     */
    function handleNamedExport(node, loc) {
        if (node.declaration) {
            handleDeclaration(node.declaration);
        }
        else if (node.specifiers.length > 0) {
            handleSpecifiers(node.specifiers);
        }
        function handleDeclaration(declaration) {
            var _a;
            if (declaration.type === 'VariableDeclaration') {
                declaration.declarations.forEach((d) => {
                    handleBindingName(d.id);
                });
            }
            else if (((_a = declaration.id) === null || _a === void 0 ? void 0 : _a.type) === 'Identifier') {
                reportIfDuplicate(node, declaration.id.name, loc);
            }
        }
        function handleBindingName(id) {
            if (id.type === 'Identifier') {
                reportIfDuplicate(node, id.name, loc);
            }
            else if (id.type === 'ObjectPattern') {
                id.properties.forEach((p) => {
                    if (p.type === 'Property' && p.value.type === 'Identifier') {
                        reportIfDuplicate(node, p.value.name, loc);
                    }
                    else if (p.type === 'RestElement' && p.argument.type === 'Identifier') {
                        reportIfDuplicate(node, p.argument.name, loc);
                    }
                });
            }
        }
        function handleSpecifiers(specifiers) {
            specifiers.forEach(s => {
                reportIfDuplicate(node, s.exported.name, loc);
            });
        }
    }
    /**
     * Handles an `export *` statement by first resolving the original source file of the export, and then
     * parsing the AST for the original source.
     *
     * @param exportAllNode
     * @param sourceFile the source file to use for resolving import statements
     * @param loc the source location of the top level export * node
     */
    function handleExportAll(exportAllNode, sourceFile = context.getFilename(), loc) {
        if (!exportAllNode.source) {
            return;
        }
        const topLevelExportAllNodeLocation = loc !== null && loc !== void 0 ? loc : exportAllNode.loc;
        const exportSource = exportAllNode.source.value;
        const sourceFilePath = (0, resolve_1.relative)(exportSource, sourceFile, Object.assign(Object.assign({}, context.settings), { 'import/resolver': 'typescript' }));
        const sourceCode = (0, fs_1.readFileSync)(sourceFilePath, 'utf-8');
        const ast = (0, typescript_estree_1.parse)(sourceCode, {
            loc: true,
            jsx: true
        });
        ast.body.forEach(astNode => {
            if (astNode.type === 'ExportNamedDeclaration') {
                handleNamedExport(astNode, topLevelExportAllNodeLocation);
            }
            else if (astNode.type === 'ExportAllDeclaration') {
                handleExportAll(astNode, sourceFilePath, topLevelExportAllNodeLocation);
            }
        });
    }
    return {
        ExportNamedDeclaration: handleNamedExport,
        ExportAllDeclaration: handleExportAll
    };
}
